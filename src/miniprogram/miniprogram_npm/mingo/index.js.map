{"version":3,"sources":["mingo.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["// mingo.js 1.3.3\n// Copyright (c) 2017 Francis Asante\n// https://github.com/kofrasa/mingo\n// MIT\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.mingo = factory());\n}(this, (function () { \n\n/**\n * Polyfill to add native methods for non-supported environments.\n */\n\n// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function (oThis) {\n    if (typeof this !== 'function') {\n      // closest thing possible to the ECMAScript 5\n      // internal IsCallable function\n      throw new Error('Function.prototype.bind - what is trying to be bound is not callable');\n    }\n\n    var aArgs = Array.prototype.slice.call(arguments, 1);\n    var fToBind = this;\n    var fNOP = function fNOP() {};\n    var fBound = function fBound() {\n      return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\n    };\n\n    if (this.prototype) {\n      // Function.prototype doesn't have a prototype property\n      fNOP.prototype = this.prototype;\n    }\n    fBound.prototype = new fNOP();\n\n    return fBound;\n  };\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find\nif (!Array.prototype.find) {\n  Object.defineProperty(Array.prototype, 'find', {\n    value: function value(predicate) {\n      if (this == null) {\n        throw new TypeError('\"this\" is null or not defined');\n      }\n\n      var o = Object(this);\n      var len = o.length >>> 0;\n\n      if (typeof predicate !== 'function') {\n        throw new TypeError('predicate must be a function');\n      }\n\n      var thisArg = arguments[1];\n      var k = 0;\n\n      while (k < len) {\n        var kValue = o[k];\n        if (predicate.call(thisArg, kValue, k, o)) {\n          return kValue;\n        }\n        k++;\n      }\n      return undefined;\n    }\n  });\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex\nif (!Array.prototype.findIndex) {\n  Object.defineProperty(Array.prototype, 'findIndex', {\n    value: function value(predicate) {\n      if (this == null) {\n        throw new TypeError('\"this\" is null or not defined');\n      }\n\n      var o = Object(this);\n      var len = o.length >>> 0;\n\n      if (typeof predicate !== 'function') {\n        throw new TypeError('predicate must be a function');\n      }\n\n      var thisArg = arguments[1];\n      var k = 0;\n      while (k < len) {\n        var kValue = o[k];\n        if (predicate.call(thisArg, kValue, k, o)) {\n          return k;\n        }\n        k++;\n      }\n      return -1;\n    }\n  });\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes\nif (!Array.prototype.includes) {\n  Object.defineProperty(Array.prototype, 'includes', {\n    value: function value(searchElement, fromIndex) {\n      if (this == null) {\n        throw new TypeError('\"this\" is null or not defined');\n      }\n\n      var o = Object(this);\n      var len = o.length >>> 0;\n\n      if (len === 0) {\n        return false;\n      }\n      var n = fromIndex | 0;\n      var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n\n      function sameValueZero(x, y) {\n        return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);\n      }\n\n      while (k < len) {\n        if (sameValueZero(o[k], searchElement)) {\n          return true;\n        }\n        k++;\n      }\n      return false;\n    }\n  });\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\nif (typeof Object.assign != 'function') {\n  Object.assign = function (target, varArgs) {\n    // .length of function is 2\n\n    if (target == null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var to = Object(target);\n    var args = Array.prototype.slice.call(arguments);\n\n    for (var index = 1; index < args.length; index++) {\n      var nextSource = args[index];\n\n      if (nextSource != null) {\n        // Skip over if undefined or null\n        for (var nextKey in nextSource) {\n          // Avoid bugs when hasOwnProperty is shadowed\n          if (nextSource.hasOwnProperty(nextKey)) {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n    }\n    return to;\n  };\n}\n\n// http://tokenposts.blogspot.co.za/2012/04/javascript-objectkeys-browser.html\nif (!Object.keys) {\n  Object.keys = function (o) {\n    if (o !== Object(o)) {\n      throw new TypeError('Object.keys called on a non-object');\n    }\n\n    var result = [];\n    for (var k in o) {\n      if (o.hasOwnProperty(k)) {\n        result.push(k);\n      }\n    }\n    return result;\n  };\n}\n\n// https://github.com/es-shims/Object.values/blob/master/implementation.js\nif (!Object.values) {\n  Object.values = function (o) {\n    if (o !== Object(o)) {\n      throw new TypeError('Object.values called on a non-object');\n    }\n    var result = [];\n    for (var k in o) {\n      if (o.hasOwnProperty(k)) {\n        result.push(o[k]);\n      }\n    }\n    return result;\n  };\n}\n\n// Javascript native types\nvar T_NULL = 'null';\nvar T_UNDEFINED = 'undefined';\nvar T_BOOL = 'bool';\nvar T_BOOLEAN = 'boolean';\nvar T_NUMBER = 'number';\nvar T_STRING = 'string';\nvar T_DATE = 'date';\nvar T_REGEX = 'regex';\nvar T_REGEXP = 'regexp';\nvar T_ARRAY = 'array';\nvar T_OBJECT = 'object';\nvar T_FUNCTION = 'function';\n\n// no array, object, or function types\nvar JS_SIMPLE_TYPES = [T_NULL, T_UNDEFINED, T_BOOLEAN, T_NUMBER, T_STRING, T_DATE, T_REGEXP];\n\n// operator classes\nvar OP_AGGREGATE = 'aggregate';\nvar OP_GROUP = 'group';\nvar OP_PIPELINE = 'pipeline';\nvar OP_PROJECTION = 'projection';\nvar OP_QUERY = 'query';\n\n/**\n * Utility functions\n */\n\nfunction assert(condition, message) {\n  if (falsey(condition)) err(message);\n}\n\n/**\n * Deep clone an object\n * @param obj\n * @returns {*}\n */\nfunction clone(obj) {\n  switch (jsType(obj)) {\n    case T_ARRAY:\n      return obj.map(clone);\n    case T_OBJECT:\n      return map(obj, clone);\n    default:\n      return obj;\n  }\n}\n\nfunction getType(v) {\n  if (v === null) return 'Null';\n  if (v === undefined) return 'Undefined';\n  return v.constructor.name;\n}\nfunction jsType(v) {\n  return getType(v).toLowerCase();\n}\nfunction isBoolean(v) {\n  return jsType(v) === T_BOOLEAN;\n}\nfunction isString(v) {\n  return jsType(v) === T_STRING;\n}\nfunction isNumber(v) {\n  return jsType(v) === T_NUMBER;\n}\nfunction isArray(v) {\n  return jsType(v) === T_ARRAY;\n}\nfunction isArrayLike(v) {\n  return !isNil(v) && has(v, 'length');\n}\nfunction isObject(v) {\n  return jsType(v) === T_OBJECT;\n}\nfunction isObjectLike(v) {\n  return v === Object(v);\n} // objects, arrays, functions, date, custom object\nfunction isDate(v) {\n  return jsType(v) === T_DATE;\n}\nfunction isRegExp(v) {\n  return jsType(v) === T_REGEXP;\n}\nfunction isFunction(v) {\n  return jsType(v) === T_FUNCTION;\n}\nfunction isNil(v) {\n  return isNull(v) || isUndefined(v);\n}\nfunction isNull(v) {\n  return jsType(v) === T_NULL;\n}\nfunction isUndefined(v) {\n  return jsType(v) === T_UNDEFINED;\n}\nfunction inArray(arr, item) {\n  return arr.includes(item);\n}\nfunction notInArray(arr, item) {\n  return !arr.includes(item);\n}\nfunction truthy(arg) {\n  return !!arg;\n}\nfunction falsey(arg) {\n  return !arg;\n}\nfunction isEmpty(x) {\n  return isNil(x) || isArray(x) && x.length === 0 || isObject(x) && keys(x).length === 0 || !x;\n}\n// ensure a value is an array\nfunction array(x) {\n  return isArray(x) ? x : [x];\n}\nfunction has(obj, prop) {\n  return obj.hasOwnProperty(prop);\n}\nfunction err(s) {\n  throw new Error(s);\n}\nfunction keys(o) {\n  return Object.keys(o);\n}\n\n// ////////////////// UTILS ////////////////////\n\n// internal constants\nvar __MINGO_META = '__mingo__';\n\nfunction addMeta(obj, value) {\n  obj[__MINGO_META] = Object.assign(obj[__MINGO_META] || {}, value);\n}\n\nfunction hasMeta(obj, value) {\n  return has(obj, __MINGO_META) && isObject(value) && isEqual(Object.assign({}, obj[__MINGO_META], value), obj[__MINGO_META]);\n}\n\nfunction dropMeta(obj) {\n  if (has(obj, __MINGO_META)) delete obj[__MINGO_META];\n}\n\n/**\n * Iterate over an array or object\n * @param  {Array|Object} obj An object-like value\n * @param  {Function} fn The callback to run per item\n * @param  {*}   ctx  The object to use a context\n * @return {void}\n */\nfunction each(obj, fn) {\n  var ctx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  assert(obj === Object(obj), \"Cannot iterate over object of type '\" + jsType(obj) + \"'\");\n\n  if (isArrayLike(obj)) {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      if (fn.call(ctx, obj[i], i, obj) === false) break;\n    }\n  } else {\n    for (var k in obj) {\n      if (has(obj, k)) {\n        if (fn.call(ctx, obj[k], k, obj) === false) break;\n      }\n    }\n  }\n}\n\n/**\n * Transform values in a collection\n *\n * @param  {Array|Object}   obj   An array/object whose values to transform\n * @param  {Function} fn The transform function\n * @param  {*}   ctx The value to use as the \"this\" context for the transform\n * @return {Array|Object} Result object after applying the transform\n */\nfunction map(obj, fn) {\n  var ctx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  if (isArray(obj)) {\n    return obj.map(fn, ctx);\n  } else if (isObject(obj)) {\n    var o = {};\n    each(obj, function (v, k) {\n      return o[k] = fn.call(ctx, v, k);\n    }, obj);\n    return o;\n  }\n}\n\n/**\n * Reduce any array-like object\n * @param collection\n * @param fn\n * @param accumulator\n * @returns {*}\n */\nfunction reduce(collection, fn, accumulator) {\n  if (isArray(collection)) return collection.reduce(fn, accumulator);\n  // array-like objects\n  each(collection, function (v, k) {\n    return accumulator = fn(accumulator, v, k, collection);\n  });\n  return accumulator;\n}\n\n/**\n * Returns the intersection between two arrays\n *\n * @param  {Array} xs The first array\n * @param  {Array} ys The second array\n * @return {Array}    Result array\n */\nfunction intersection(xs, ys) {\n  return xs.filter(inArray.bind(null, ys));\n}\n\n/**\n * Returns the union of two arrays\n *\n * @param  {Array} xs The first array\n * @param  {Array} ys The second array\n * @return {Array}   The result array\n */\nfunction union(xs, ys) {\n  return into(into([], xs), ys.filter(notInArray.bind(null, xs)));\n}\n\n/**\n * Flatten the array\n *\n * @param  {Array} xs The array to flatten\n * @param {Number} depth The number of nested lists to iterate\n */\n\n\n/**\n * Determine whether two values are the same or strictly equivalent\n *\n * @param  {*}  a The first value\n * @param  {*}  b The second value\n * @return {Boolean}   Result of comparison\n */\nfunction isEqual(a, b) {\n  // strictly equal must be equal.\n  if (a === b) return true;\n\n  // unequal types and functions cannot be equal.\n  var type = jsType(a);\n  if (type !== jsType(b) || type === T_FUNCTION) return false;\n\n  // we treat NaN as the same\n  if (type === T_NUMBER && isNaN(a) && isNaN(b)) return true;\n\n  // leverage toString for Date and RegExp types\n  if (inArray([T_DATE, T_REGEXP], type)) return a.toString() === b.toString();\n\n  if (type === T_ARRAY) {\n    if (a.length === b.length && a.length === 0) return true;\n    if (a.length !== b.length) return false;\n    for (var i = 0, len = a.length; i < len; i++) {\n      if (!isEqual(a[i], b[i])) return false;\n    }\n  } else if (type === T_OBJECT) {\n    // deep compare objects\n    var ka = keys(a);\n    var kb = keys(b);\n\n    // check length of keys early\n    if (ka.length !== kb.length) return false;\n\n    // we know keys are strings so we sort before comparing\n    ka.sort();\n    kb.sort();\n\n    // compare keys\n    if (!isEqual(ka, kb)) return false;\n\n    // back to the drawing board\n    for (var _i = 0, _len = ka.length; _i < _len; _i++) {\n      var temp = ka[_i];\n      if (!isEqual(a[temp], b[temp])) return false;\n    }\n  } else {\n    // we do not know how to compare custom types so we guess\n    return getHash(a) === getHash(b);\n  }\n  // best effort says values are equal :)\n  return true;\n}\n\n/**\n * Return a new unique version of the collection\n * @param  {Array} xs The input collection\n * @return {Array}    A new collection with unique values\n */\nfunction unique(xs) {\n  var h = {};\n  var arr = [];\n  each(xs, function (item) {\n    var k = getHash(item);\n    if (!has(h, k)) {\n      arr.push(item);\n      h[k] = 0;\n    }\n  });\n  return arr;\n}\n\n/**\n * Generates a random string of max length range [24,27]\n * @param n Size of string to return\n * @returns {*}\n */\nfunction randomString(n) {\n  return (Math.E + Math.random()).toString(36).slice(2, n + 2);\n}\n\n/**\n * Encode value using a simple optimistic stable scheme.\n * @param value\n * @returns {*}\n */\nfunction encode(value) {\n  var type = jsType(value);\n  switch (type) {\n    case T_FUNCTION:\n      return randomString(7);\n    case T_BOOLEAN:\n    case T_NUMBER:\n    case T_REGEXP:\n      return value.toString();\n    case T_STRING:\n      return JSON.stringify(value);\n    case T_DATE:\n      return value.toISOString();\n    case T_NULL:\n    case T_UNDEFINED:\n      return type;\n    case T_ARRAY:\n      return '[' + map(value, function (v) {\n        return '' + encode(v);\n      }) + ']';\n    default:\n      var prefix = type === T_OBJECT ? '' : getType(value) + '|';\n      var objKeys = keys(value);\n      objKeys.sort();\n      return prefix + '{' + map(objKeys, function (k) {\n        return encode(k) + ':' + encode(value[k]);\n      }) + '}';\n  }\n}\n\n/**\n * Generate hash code\n * http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n *\n * @param value\n * @returns {*}\n */\nfunction getHash(value) {\n  var hash = 0,\n      i = void 0,\n      chr = void 0,\n      len = void 0,\n      s = encode(value);\n  if (s.length === 0) return hash;\n  for (i = 0, len = s.length; i < len; i++) {\n    chr = s.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return hash.toString();\n}\n\n/**\n * Returns a (stably) sorted copy of list, ranked in ascending order by the results of running each value through iteratee\n *\n * This implementation treats null/undefined sort keys as less than every other type\n *\n * @param  {Array}   collection\n * @param  {Function} fn The function used to resolve sort keys\n * @param {Object} ctx The context to use for calling `fn`\n * @return {Array} Returns a new sorted array by the given iteratee\n */\nfunction sortBy(collection, fn) {\n  var ctx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  var sortKeys = {};\n  var sorted = [];\n  var len = collection.length;\n  var result = [];\n\n  for (var i = 0; i < len; i++) {\n    var obj = collection[i];\n    var key = fn.call(ctx, obj, i);\n    if (isNil(key)) {\n      // objects with null keys will go in first\n      result.push(obj);\n    } else {\n      var hash = getHash(obj);\n      if (!has(sortKeys, hash)) {\n        sortKeys[hash] = [key, i];\n      }\n      sorted.push(obj);\n    }\n  }\n  // use native array sorting but enforce stableness\n  sorted.sort(function (a, b) {\n    var A = sortKeys[getHash(a)];\n    var B = sortKeys[getHash(b)];\n    if (A[0] < B[0]) return -1;\n    if (A[0] > B[0]) return 1;\n    if (A[1] < B[1]) return -1;\n    if (A[1] > B[1]) return 1;\n    return 0;\n  });\n  return into(result, sorted);\n}\n\n/**\n * Groups the collection into sets by the returned key\n *\n * @param collection\n * @param fn {Function} to compute the group key of an item in the collection\n * @param ctx {Object} The context to use for calling `fn`\n * @returns {{keys: Array, groups: Array}}\n */\nfunction groupBy(collection, fn, ctx) {\n  var result = {\n    'keys': [],\n    'groups': []\n  };\n  var lookup = {};\n  each(collection, function (obj) {\n    var key = fn.call(ctx, obj);\n    var hash = getHash(key);\n    var index = -1;\n\n    if (isUndefined(lookup[hash])) {\n      index = result.keys.length;\n      lookup[hash] = index;\n      result.keys.push(key);\n      result.groups.push([]);\n    }\n    index = lookup[hash];\n    result.groups[index].push(obj);\n  });\n  return result;\n}\n\n/**\n * Push elements in given array into target array\n *\n * @param {*} target The array to push into\n * @param {*} xs The array of elements to push\n */\nfunction into(target, xs) {\n  Array.prototype.push.apply(target, xs);\n  return target;\n}\n\n/**\n * Find the insert index for the given key in a sorted array.\n *\n * @param {*} array The sorted array to search\n * @param {*} key The search key\n */\nfunction findInsertIndex(array, key) {\n  // uses binary search\n  var lo = 0;\n  var hi = array.length - 1;\n  while (lo <= hi) {\n    var mid = Math.round(lo + (hi - lo) / 2);\n    if (key < array[mid]) {\n      hi = mid - 1;\n    } else if (key > array[mid]) {\n      lo = mid + 1;\n    } else {\n      return mid;\n    }\n  }\n  return lo;\n}\n\n/**\n * This is a generic memoization function\n *\n * This implementation uses a cache independent of the function being memoized\n * to allow old values to be garbage collected when the memoized function goes out of scope.\n *\n * @param {*} fn The function object to memoize\n */\nfunction memoize(fn) {\n  var _this = this;\n\n  return function (cache) {\n    return function () {\n      for (var _len2 = arguments.length, args = Array(_len2), _key = 0; _key < _len2; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var key = getHash(args);\n      if (!has(cache, key)) {\n        cache[key] = fn.apply(_this, args);\n      }\n      return cache[key];\n    };\n  }({/* storage */});\n}\n\n/**\n * Group stage Accumulator Operators. https://docs.mongodb.com/manual/reference/operator/aggregation-group/\n */\n\nvar groupOperators = {\n\n  /**\n   * Returns an array of all the unique values for the selected field among for each document in that group.\n   *\n   * @param collection\n   * @param expr\n   * @returns {*}\n   */\n  $addToSet: function $addToSet(collection, expr) {\n    return unique(this.$push(collection, expr));\n  },\n\n\n  /**\n   * Returns the sum of all the values in a group.\n   *\n   * @param collection\n   * @param expr\n   * @returns {*}\n   */\n  $sum: function $sum(collection, expr) {\n    if (!isArray(collection)) return 0;\n\n    if (isNumber(expr)) {\n      // take a short cut if expr is number literal\n      return collection.length * expr;\n    }\n    return reduce(this.$push(collection, expr).filter(isNumber), function (acc, n) {\n      return acc + n;\n    }, 0);\n  },\n\n\n  /**\n   * Returns the highest value in a group.\n   *\n   * @param collection\n   * @param expr\n   * @returns {*}\n   */\n  $max: function $max(collection, expr) {\n    var mapped = this.$push(collection, expr);\n    return reduce(mapped, function (acc, n) {\n      return isNil(acc) || n > acc ? n : acc;\n    }, undefined);\n  },\n\n\n  /**\n   * Returns the lowest value in a group.\n   *\n   * @param collection\n   * @param expr\n   * @returns {*}\n   */\n  $min: function $min(collection, expr) {\n    var mapped = this.$push(collection, expr);\n    return reduce(mapped, function (acc, n) {\n      return isNil(acc) || n < acc ? n : acc;\n    }, undefined);\n  },\n\n\n  /**\n   * Returns an average of all the values in a group.\n   *\n   * @param collection\n   * @param expr\n   * @returns {number}\n   */\n  $avg: function $avg(collection, expr) {\n    var data = this.$push(collection, expr).filter(isNumber);\n    var sum = reduce(data, function (acc, n) {\n      return acc + n;\n    }, 0);\n    return sum / (data.length || 1);\n  },\n\n\n  /**\n   * Returns an array of all values for the selected field among for each document in that group.\n   *\n   * @param collection\n   * @param expr\n   * @returns {Array|*}\n   */\n  $push: function $push(collection, expr) {\n    if (isNil(expr)) return collection;\n    return map(collection, function (obj) {\n      return computeValue(obj, expr);\n    });\n  },\n\n\n  /**\n   * Returns the first value in a group.\n   *\n   * @param collection\n   * @param expr\n   * @returns {*}\n   */\n  $first: function $first(collection, expr) {\n    return collection.length > 0 ? computeValue(collection[0], expr) : undefined;\n  },\n\n\n  /**\n   * Returns the last value in a group.\n   *\n   * @param collection\n   * @param expr\n   * @returns {*}\n   */\n  $last: function $last(collection, expr) {\n    return collection.length > 0 ? computeValue(collection[collection.length - 1], expr) : undefined;\n  },\n\n\n  /**\n   * Returns the population standard deviation of the input values.\n   * @param  {Array} collection\n   * @param  {Object} expr\n   * @return {Number}\n   */\n  $stdDevPop: function $stdDevPop(collection, expr) {\n    var data = this.$push(collection, expr).filter(isNumber);\n    return stddev({ data: data, sampled: false });\n  },\n\n\n  /**\n   * Returns the sample standard deviation of the input values.\n   * @param  {Array} collection\n   * @param  {Object} expr\n   * @return {Number|null}\n   */\n  $stdDevSamp: function $stdDevSamp(collection, expr) {\n    var data = this.$push(collection, expr).filter(isNumber);\n    return stddev({ data: data, sampled: true });\n  }\n};\n\n/**\n * Projection Operators. https://docs.mongodb.com/manual/reference/operator/projection/\n */\nvar projectionOperators = {\n\n  /**\n   * Projects the first element in an array that matches the query condition.\n   *\n   * @param obj\n   * @param field\n   * @param expr\n   */\n  $: function $(obj, expr, field) {\n    err('$ not implemented');\n  },\n\n\n  /**\n   * Projects only the first element from an array that matches the specified $elemMatch condition.\n   *\n   * @param obj\n   * @param field\n   * @param expr\n   * @returns {*}\n   */\n  $elemMatch: function $elemMatch(obj, expr, field) {\n    var arr = resolve(obj, field);\n    var query = new Query(expr);\n\n    if (isNil(arr) || !isArray(arr)) {\n      return undefined;\n    }\n\n    for (var i = 0; i < arr.length; i++) {\n      if (query.test(arr[i])) {\n        return [arr[i]];\n      }\n    }\n\n    return undefined;\n  },\n\n\n  /**\n   * Limits the number of elements projected from an array. Supports skip and limit slices.\n   *\n   * @param obj\n   * @param field\n   * @param expr\n   */\n  $slice: function $slice(obj, expr, field) {\n    var xs = resolve(obj, field);\n\n    if (!isArray(xs)) return xs;\n\n    if (isArray(expr)) {\n      return slice(xs, expr[0], expr[1]);\n    } else if (isNumber(expr)) {\n      return slice(xs, expr);\n    } else {\n      err('Invalid argument type for $slice projection operator');\n    }\n  },\n\n\n  /**\n   * Returns the population standard deviation of the input values.\n   * @param  {Object} obj\n   * @param  {Object} expr\n   * @param  {String} field\n   * @return {Number}\n   */\n  $stdDevPop: function $stdDevPop(obj, expr, field) {\n    return stddev({\n      data: computeValue(obj, expr, field),\n      sampled: false\n    });\n  },\n\n\n  /**\n   * Returns the sample standard deviation of the input values.\n   * @param  {Object} obj\n   * @param  {Object} expr\n   * @param  {String} field\n   * @return {Number|null}\n   */\n  $stdDevSamp: function $stdDevSamp(obj, expr, field) {\n    return stddev({\n      data: computeValue(obj, expr, field),\n      sampled: true\n    });\n  }\n};\n\n/**\n * Pipeline Aggregation Stages. https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/\n */\nvar pipelineOperators = {\n\n  /**\n   * Adds new fields to documents.\n   * Outputs documents that contain all existing fields from the input documents and newly added fields.\n   *\n   * @param {Array} collection\n   * @param {*} expr\n   */\n  $addFields: function $addFields(collection, expr) {\n    var newFields = keys(expr);\n\n    return collection.map(function (obj) {\n      obj = clone(obj);\n      each(newFields, function (field) {\n        var subExpr = expr[field];\n        var newValue = computeValue(obj, subExpr);\n        traverse(obj, field, function (o, key) {\n          o[key] = newValue;\n        }, true);\n      });\n      return obj;\n    });\n  },\n\n\n  /**\n   * Groups documents together for the purpose of calculating aggregate values based on a collection of documents.\n   *\n   * @param collection\n   * @param expr\n   * @returns {Array}\n   */\n  $group: function $group(collection, expr) {\n    // lookup key for grouping\n    var ID_KEY = idKey();\n    var objectId = expr[ID_KEY];\n\n    var partitions = groupBy(collection, function (obj) {\n      return computeValue(obj, objectId, objectId);\n    });\n\n    var result = [];\n\n    // remove the group key\n    delete expr[ID_KEY];\n\n    each(partitions.keys, function (value, i) {\n      var obj = {};\n\n      // exclude undefined key value\n      if (!isUndefined(value)) {\n        obj[ID_KEY] = value;\n      }\n\n      // compute remaining keys in expression\n      each(expr, function (val, key) {\n        obj[key] = accumulate(partitions.groups[i], key, val);\n      });\n      result.push(obj);\n    });\n\n    return result;\n  },\n\n\n  /**\n   * Performs a left outer join to another collection in the same database to filter in documents from the “joined” collection for processing.\n   *\n   * @param collection\n   * @param expr\n   */\n  $lookup: function $lookup(collection, expr) {\n    var joinColl = expr.from;\n    var localField = expr.localField;\n    var foreignField = expr.foreignField;\n    var asField = expr.as;\n\n    var errorMsg = \"Invalid $lookup expression. \";\n    assert(isArray(joinColl), errorMsg + \"'from' must be an array\");\n    assert(isString(foreignField), errorMsg + \"'foreignField' must be a string\");\n    assert(isString(localField), errorMsg + \"'localField' must be a string\");\n    assert(isString(asField), errorMsg + \"'as' must be a string\");\n\n    var result = [];\n    var hash = {};\n\n    function hashCode(v) {\n      return getHash(isNil(v) ? null : v);\n    }\n\n    if (joinColl.length <= collection.length) {\n      each(joinColl, function (obj, i) {\n        var k = hashCode(obj[foreignField]);\n        hash[k] = hash[k] || [];\n        hash[k].push(i);\n      });\n\n      each(collection, function (obj) {\n        var k = hashCode(obj[localField]);\n        var indexes = hash[k] || [];\n        var newObj = clone(obj);\n        newObj[asField] = indexes.map(function (i) {\n          return clone(joinColl[i]);\n        });\n        result.push(newObj);\n      });\n    } else {\n\n      each(collection, function (obj, i) {\n        var k = hashCode(obj[localField]);\n        hash[k] = hash[k] || [];\n        hash[k].push(i);\n      });\n\n      var tempResult = {};\n      each(joinColl, function (obj) {\n        var k = hashCode(obj[foreignField]);\n        var indexes = hash[k] || [];\n        each(indexes, function (i) {\n          var newObj = tempResult[i] || clone(collection[i]);\n          newObj[asField] = newObj[asField] || [];\n          newObj[asField].push(clone(obj));\n          tempResult[i] = newObj;\n        });\n      });\n      for (var i = 0, len = keys(tempResult).length; i < len; i++) {\n        result.push(tempResult[i]);\n      }\n    }\n\n    return result;\n  },\n\n\n  /**\n   * Filters the document stream, and only allows matching documents to pass into the next pipeline stage.\n   * $match uses standard MongoDB queries.\n   *\n   * @param collection\n   * @param expr\n   * @returns {Array|*}\n   */\n  $match: function $match(collection, expr) {\n    return new Query(expr).find(collection).all();\n  },\n\n\n  /**\n   * Reshapes a document stream.\n   * $project can rename, add, or remove fields as well as create computed values and sub-documents.\n   *\n   * @param collection\n   * @param expr\n   * @returns {Array}\n   */\n  $project: function $project(collection, expr) {\n    if (isEmpty(expr)) {\n      return collection;\n    }\n\n    // result collection\n    var projected = [];\n    var objKeys = keys(expr);\n    var idOnlyExcludedExpression = false;\n    var ID_KEY = idKey();\n\n    // validate inclusion and exclusion\n    var check = [false, false];\n    each(expr, function (v, k) {\n      if (k === ID_KEY) return;\n      if (v === 0 || v === false) {\n        check[0] = true;\n      } else {\n        check[1] = true;\n      }\n      assert(check[0] !== check[1], 'Projection cannot have a mix of inclusion and exclusion.');\n    });\n\n    if (inArray(objKeys, ID_KEY)) {\n      var id = expr[ID_KEY];\n      if (id === 0 || id === false) {\n        objKeys = objKeys.filter(notInArray.bind(null, [ID_KEY]));\n        assert(notInArray(objKeys, ID_KEY), 'Must not contain collections id key');\n        idOnlyExcludedExpression = isEmpty(objKeys);\n      }\n    } else {\n      // if not specified the add the ID field\n      objKeys.push(ID_KEY);\n    }\n\n    each(collection, function (obj) {\n      var cloneObj = {};\n      var foundSlice = false;\n      var foundExclusion = false;\n      var dropKeys = [];\n\n      if (idOnlyExcludedExpression) {\n        dropKeys.push(ID_KEY);\n      }\n\n      each(objKeys, function (key) {\n        var subExpr = expr[key];\n        var value = void 0; // final computed value of the key\n\n        if (key !== ID_KEY && subExpr === 0) {\n          foundExclusion = true;\n        }\n\n        if (key === ID_KEY && isEmpty(subExpr)) {\n          // tiny optimization here to skip over id\n          value = obj[key];\n        } else if (isString(subExpr)) {\n          value = computeValue(obj, subExpr, key);\n        } else if (subExpr === 1 || subExpr === true) {\n          // For direct projections, we use the resolved object value\n        } else if (isObject(subExpr)) {\n          var operator = keys(subExpr);\n          operator = operator.length > 1 ? false : operator[0];\n\n          if (inArray(ops(OP_PROJECTION), operator)) {\n            // apply the projection operator on the operator expression for the key\n            if (operator === '$slice') {\n              // $slice is handled differently for aggregation and projection operations\n              if (array(subExpr[operator]).every(isNumber)) {\n                // $slice for projection operation\n                value = projectionOperators[operator](obj, subExpr[operator], key);\n                foundSlice = true;\n              } else {\n                // $slice for aggregation operation\n                value = computeValue(obj, subExpr, key);\n              }\n            } else {\n              value = projectionOperators[operator](obj, subExpr[operator], key);\n            }\n          } else {\n            // compute the value for the sub expression for the key\n            value = computeValue(obj, subExpr, key);\n          }\n        } else {\n          dropKeys.push(key);\n          return;\n        }\n\n        // clone resolved values\n        var objValue = clone(resolveObj(obj, key));\n\n        if (!isUndefined(objValue)) {\n          Object.assign(cloneObj, objValue);\n        }\n        if (!isUndefined(value)) {\n          setValue(cloneObj, key, clone(value));\n        }\n      });\n      // if projection included $slice operator\n      // Also if exclusion fields are found or we want to exclude only the id field\n      // include keys that were not explicitly excluded\n      if (foundSlice || foundExclusion || idOnlyExcludedExpression) {\n        cloneObj = Object.assign(clone(obj), cloneObj);\n        each(dropKeys, function (key) {\n          return removeValue(cloneObj, key);\n        });\n      }\n      projected.push(cloneObj);\n    });\n\n    return projected;\n  },\n\n\n  /**\n   * Restricts the number of documents in an aggregation pipeline.\n   *\n   * @param collection\n   * @param value\n   * @returns {Object|*}\n   */\n  $limit: function $limit(collection, value) {\n    return collection.slice(0, value);\n  },\n\n\n  /**\n   * Skips over a specified number of documents from the pipeline and returns the rest.\n   *\n   * @param collection\n   * @param value\n   * @returns {*}\n   */\n  $skip: function $skip(collection, value) {\n    return collection.slice(value);\n  },\n\n\n  /**\n   * Takes an array of documents and returns them as a stream of documents.\n   *\n   * @param collection\n   * @param expr\n   * @returns {Array}\n   */\n  $unwind: function $unwind(collection, expr) {\n    var result = [];\n    var field = expr.substr(1);\n    each(collection, function (obj) {\n      // must throw an error if value is not an array\n      var value = getValue(obj, field);\n\n      assert(isArray(value), \"Target field '\" + field + \"' is not of type Array.\");\n\n      each(value, function (item) {\n        var tmp = clone(obj);\n        tmp[field] = item;\n        result.push(tmp);\n      });\n    });\n    return result;\n  },\n\n\n  /**\n   * Takes all input documents and returns them in a stream of sorted documents.\n   *\n   * @param collection\n   * @param sortKeys\n   * @returns {*}\n   */\n  $sort: function $sort(collection, sortKeys) {\n    if (!isEmpty(sortKeys) && isObject(sortKeys)) {\n      var modifiers = keys(sortKeys);\n      each(modifiers.reverse(), function (key) {\n        var grouped = groupBy(collection, function (obj) {\n          return resolve(obj, key);\n        });\n        var sortedIndex = {};\n        var getIndex = function getIndex(k) {\n          return sortedIndex[getHash(k)];\n        };\n\n        var indexKeys = sortBy(grouped.keys, function (item, i) {\n          sortedIndex[getHash(item)] = i;\n          return item;\n        });\n\n        if (sortKeys[key] === -1) {\n          indexKeys.reverse();\n        }\n        collection = [];\n        each(indexKeys, function (item) {\n          return into(collection, grouped.groups[getIndex(item)]);\n        });\n      });\n    }\n    return collection;\n  },\n\n\n  /**\n   * Groups incoming documents based on the value of a specified expression,\n   * then computes the count of documents in each distinct group.\n   *\n   * https://docs.mongodb.com/manual/reference/operator/aggregation/sortByCount/\n   *\n   * @param  {Array} collection\n   * @param  {Object} expr\n   * @return {*}\n   */\n  $sortByCount: function $sortByCount(collection, expr) {\n    var newExpr = { count: { $sum: 1 } };\n    newExpr[idKey()] = expr;\n\n    return this.$sort(this.$group(collection, newExpr), { count: -1 });\n  },\n\n\n  /**\n   * Randomly selects the specified number of documents from its input.\n   * https://docs.mongodb.com/manual/reference/operator/aggregation/sample/\n   *\n   * @param  {Array} collection\n   * @param  {Object} expr\n   * @return {*}\n   */\n  $sample: function $sample(collection, expr) {\n    var size = expr.size;\n    assert(isNumber(size), '$sample size must be a positive integer');\n\n    var result = [];\n    var len = collection.length;\n    for (var i = 0; i < size; i++) {\n      var n = Math.floor(Math.random() * len);\n      result.push(collection[n]);\n    }\n    return result;\n  },\n\n\n  /**\n   * Returns a document that contains a count of the number of documents input to the stage.\n   * @param  {Array} collection\n   * @param  {String} expr\n   * @return {Object}\n   */\n  $count: function $count(collection, expr) {\n    assert(isString(expr) && expr.trim() !== '' && expr.indexOf('.') === -1 && expr.trim()[0] !== '$', 'Invalid expression value for $count');\n\n    var result = {};\n    result[expr] = collection.length;\n    return result;\n  },\n\n\n  /**\n   * Replaces a document with the specified embedded document or new one.\n   * The replacement document can be any valid expression that resolves to a document.\n   *\n   * https://docs.mongodb.com/manual/reference/operator/aggregation/replaceRoot/\n   *\n   * @param  {Array} collection\n   * @param  {Object} expr\n   * @return {*}\n   */\n  $replaceRoot: function $replaceRoot(collection, expr) {\n    var newRoot = expr.newRoot;\n    var result = [];\n    each(collection, function (obj) {\n      obj = computeValue(obj, newRoot);\n      assert(isObject(obj), '$replaceRoot expression must return a valid JS object');\n      result.push(obj);\n    });\n    return result;\n  },\n\n\n  /**\n   * Restricts the contents of the documents based on information stored in the documents themselves.\n   *\n   * https://docs.mongodb.com/manual/reference/operator/aggregation/redact/\n   */\n  $redact: function $redact(collection, expr) {\n    return collection.map(function (obj) {\n      return redactObj(clone(obj), expr);\n    });\n  },\n\n\n  /**\n   * Categorizes incoming documents into groups, called buckets, based on a specified expression and bucket boundaries.\n   *\n   * https://docs.mongodb.com/manual/reference/operator/aggregation/bucket/\n   */\n  $bucket: function $bucket(collection, expr) {\n    var boundaries = expr.boundaries;\n    var defaultKey = expr.default;\n    var lower = boundaries[0]; // inclusive\n    var upper = boundaries[boundaries.length - 1]; // exclusive\n    var outputExpr = expr.output || { 'count': { '$sum': 1 } };\n\n    assert(boundaries.length > 2, \"$bucket 'boundaries' expression must have at least 3 elements\");\n    var boundType = getType(lower);\n\n    for (var i = 0, len = boundaries.length - 1; i < len; i++) {\n      assert(boundType === getType(boundaries[i + 1]), \"$bucket 'boundaries' must all be of the same type\");\n      assert(boundaries[i] < boundaries[i + 1], \"$bucket 'boundaries' must be sorted in ascending order\");\n    }\n\n    if (!isNil(defaultKey) && getType(expr.default) === getType(lower)) {\n      assert(lower > expr.default || upper < expr.default, \"$bucket 'default' expression must be out of boundaries range\");\n    }\n\n    var grouped = {};\n    each(boundaries, function (k) {\n      return grouped[k] = [];\n    });\n\n    // add default key if provided\n    if (!isNil(defaultKey)) grouped[defaultKey] = [];\n\n    each(collection, function (obj) {\n      var key = computeValue(obj, expr.groupBy);\n\n      if (isNil(key) || key < lower || key >= upper) {\n        assert(!isNil(defaultKey), '$bucket require a default for out of range values');\n        grouped[defaultKey].push(obj);\n      } else if (key >= lower && key < upper) {\n        var index = findInsertIndex(boundaries, key);\n        var boundKey = boundaries[Math.max(0, index - 1)];\n        grouped[boundKey].push(obj);\n      } else {\n        err(\"$bucket 'groupBy' expression must resolve to a value in range of boundaries\");\n      }\n    });\n\n    // upper bound is exclusive so we remove it\n    boundaries.pop();\n    if (!isNil(defaultKey)) boundaries.push(defaultKey);\n\n    return map(boundaries, function (key) {\n      var acc = accumulate(grouped[key], null, outputExpr);\n      return Object.assign(acc, { '_id': key });\n    });\n  },\n  $bucketAuto: function $bucketAuto(collection, expr) {\n    var outputExpr = expr.output || { 'count': { '$sum': 1 } };\n    var groupByExpr = expr.groupBy;\n    var bucketCount = expr.buckets;\n\n    assert(bucketCount > 0, \"The $bucketAuto 'buckets' field must be greater than 0, but found: \" + bucketCount);\n\n    var approxBucketSize = Math.round(collection.length / bucketCount);\n    if (approxBucketSize < 1) {\n      approxBucketSize = 1;\n    }\n\n    var computeValueOptimized = memoize(computeValue);\n    var grouped = {};\n    var remaining = [];\n    var sorted = sortBy(collection, function (o) {\n      var key = computeValueOptimized(o, groupByExpr);\n      if (isNil(key)) {\n        remaining.push(o);\n      } else {\n        grouped[key] || (grouped[key] = []);\n        grouped[key].push(o);\n      }\n      return key;\n    });\n\n    var ID_KEY = idKey();\n    var result = [];\n    var index = 0; // counter for sorted collection\n\n    for (var i = 0, len = sorted.length; i < bucketCount && index < len; i++) {\n      var boundaries = {};\n      var bucketItems = [];\n\n      for (var j = 0; j < approxBucketSize && index < len; j++) {\n        var key = computeValueOptimized(sorted[index], groupByExpr);\n\n        if (isNil(key)) key = null;\n\n        // populate current bucket with all values for current key\n        into(bucketItems, isNil(key) ? remaining : grouped[key]);\n\n        // increase sort index by number of items added\n        index += isNil(key) ? remaining.length : grouped[key].length;\n\n        // set the min key boundary if not already present\n        if (!has(boundaries, 'min')) boundaries.min = key;\n\n        if (result.length > 0) {\n          var lastBucket = result[result.length - 1];\n          lastBucket[ID_KEY].max = boundaries.min;\n        }\n      }\n\n      // if is last bucket add remaining items\n      if (i == bucketCount - 1) {\n        into(bucketItems, sorted.slice(index));\n      }\n\n      result.push(Object.assign(accumulate(bucketItems, null, outputExpr), { '_id': boundaries }));\n    }\n\n    if (result.length > 0) {\n      result[result.length - 1][ID_KEY].max = computeValueOptimized(sorted[sorted.length - 1], groupByExpr);\n    }\n\n    return result;\n  },\n\n\n  /**\n   * Processes multiple aggregation pipelines within a single stage on the same set of input documents.\n   * Enables the creation of multi-faceted aggregations capable of characterizing data across multiple dimensions, or facets, in a single stage.\n   */\n  $facet: function $facet(collection, expr) {\n    return map(expr, function (pipeline) {\n      return aggregate(collection, pipeline);\n    });\n  }\n};\n\n/**\n * Returns the result of evaluating a $group operation over a collection\n *\n * @param collection\n * @param field the name of the aggregate operator or field\n * @param expr the expression of the aggregate operator for the field\n * @returns {*}\n */\nfunction accumulate(collection, field, expr) {\n  if (inArray(ops(OP_GROUP), field)) {\n    return groupOperators[field](collection, expr);\n  }\n\n  if (isObject(expr)) {\n    var result = {};\n    each(expr, function (val, key) {\n      result[key] = accumulate(collection, key, expr[key]);\n      // must run ONLY one group operator per expression\n      // if so, return result of the computed value\n      if (inArray(ops(OP_GROUP), key)) {\n        result = result[key];\n        // if there are more keys in expression this is bad\n        assert(keys(expr).length === 1, \"Invalid $group expression '\" + JSON.stringify(expr) + \"'\");\n        return false; // break\n      }\n    });\n    return result;\n  }\n\n  return undefined;\n}\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n/**\n * Aggregator for defining filter using mongoDB aggregation pipeline syntax\n *\n * @param operators an Array of pipeline operators\n * @constructor\n */\nvar Aggregator = function () {\n  function Aggregator(operators) {\n    classCallCheck(this, Aggregator);\n\n    this.__operators = operators;\n  }\n\n  /**\n   * Apply the pipeline operations over the collection by order of the sequence added\n   *\n   * @param collection an array of objects to process\n   * @param query the `Query` object to use as context\n   * @returns {Array}\n   */\n\n\n  createClass(Aggregator, [{\n    key: 'run',\n    value: function run(collection, query) {\n      if (!isEmpty(this.__operators)) {\n        // run aggregation pipeline\n        each(this.__operators, function (operator) {\n          var key = keys(operator);\n          assert(key.length === 1 && inArray(ops(OP_PIPELINE), key[0]), 'Invalid aggregation operator ' + key);\n          key = key[0];\n          if (query && query instanceof Query) {\n            collection = pipelineOperators[key].call(query, collection, operator[key]);\n          } else {\n            collection = pipelineOperators[key](collection, operator[key]);\n          }\n        });\n      }\n      return collection;\n    }\n  }]);\n  return Aggregator;\n}();\n\n/**\n * Return the result collection after running the aggregation pipeline for the given collection\n *\n * @param collection\n * @param pipeline\n * @returns {Array}\n */\nfunction aggregate(collection, pipeline) {\n  assert(isArray(pipeline), 'Aggregation pipeline must be an array');\n  return new Aggregator(pipeline).run(collection);\n}\n\n/**\n * Cursor to iterate and perform filtering on matched objects\n * @param collection\n * @param query\n * @param projection\n * @constructor\n */\nvar Cursor = function () {\n  function Cursor(collection, query, projection) {\n    classCallCheck(this, Cursor);\n\n    this.__query = query;\n    this.__collection = collection;\n    this.__projection = projection || query.__projection;\n    this.__operators = {};\n    this.__result = false;\n    this.__position = 0;\n  }\n\n  createClass(Cursor, [{\n    key: '_fetch',\n    value: function _fetch() {\n      var _this = this;\n\n      if (this.__result !== false) {\n        return this.__result;\n      }\n\n      // inject projection operator\n      if (isObject(this.__projection)) {\n        Object.assign(this.__operators, { '$project': this.__projection });\n      }\n\n      assert(isArray(this.__collection), 'Input collection is not of valid type. Must be an Array.');\n\n      // filter collection\n      this.__result = this.__collection.filter(this.__query.test, this.__query);\n      var pipeline = [];\n\n      each(['$sort', '$skip', '$limit', '$project'], function (op) {\n        if (has(_this.__operators, op)) {\n          var selected = {};\n          selected[op] = _this.__operators[op];\n          pipeline.push(selected);\n        }\n      });\n\n      if (pipeline.length > 0) {\n        var aggregator = new Aggregator(pipeline);\n        this.__result = aggregator.run(this.__result, this.__query);\n      }\n      return this.__result;\n    }\n\n    /**\n     * Fetch and return all matched results\n     * @returns {Array}\n     */\n\n  }, {\n    key: 'all',\n    value: function all() {\n      return this._fetch();\n    }\n\n    /**\n     * Fetch and return the first matching result\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'first',\n    value: function first() {\n      return this.count() > 0 ? this._fetch()[0] : null;\n    }\n\n    /**\n     * Fetch and return the last matching object from the result\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'last',\n    value: function last() {\n      return this.count() > 0 ? this._fetch()[this.count() - 1] : null;\n    }\n\n    /**\n     * Counts the number of matched objects found\n     * @returns {Number}\n     */\n\n  }, {\n    key: 'count',\n    value: function count() {\n      return this._fetch().length;\n    }\n\n    /**\n     * Returns a cursor that begins returning results only after passing or skipping a number of documents.\n     * @param {Number} n the number of results to skip.\n     * @return {Cursor} Returns the cursor, so you can chain this call.\n     */\n\n  }, {\n    key: 'skip',\n    value: function skip(n) {\n      Object.assign(this.__operators, { '$skip': n });\n      return this;\n    }\n\n    /**\n     * Constrains the size of a cursor's result set.\n     * @param {Number} n the number of results to limit to.\n     * @return {Cursor} Returns the cursor, so you can chain this call.\n     */\n\n  }, {\n    key: 'limit',\n    value: function limit(n) {\n      Object.assign(this.__operators, { '$limit': n });\n      return this;\n    }\n\n    /**\n     * Returns results ordered according to a sort specification.\n     * @param {Object} modifier an object of key and values specifying the sort order. 1 for ascending and -1 for descending\n     * @return {Cursor} Returns the cursor, so you can chain this call.\n     */\n\n  }, {\n    key: 'sort',\n    value: function sort(modifier) {\n      Object.assign(this.__operators, { '$sort': modifier });\n      return this;\n    }\n\n    /**\n     * Returns the next document in a cursor.\n     * @returns {Object | Boolean}\n     */\n\n  }, {\n    key: 'next',\n    value: function next() {\n      if (this.hasNext()) {\n        return this._fetch()[this.__position++];\n      }\n      return null;\n    }\n\n    /**\n     * Returns true if the cursor has documents and can be iterated.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'hasNext',\n    value: function hasNext() {\n      return this.count() > this.__position;\n    }\n\n    /**\n     * Specifies the exclusive upper bound for a specific field\n     * @param expr\n     * @returns {Number}\n     */\n\n  }, {\n    key: 'max',\n    value: function max(expr) {\n      return groupOperators.$max(this._fetch(), expr);\n    }\n\n    /**\n     * Specifies the inclusive lower bound for a specific field\n     * @param expr\n     * @returns {Number}\n     */\n\n  }, {\n    key: 'min',\n    value: function min(expr) {\n      return groupOperators.$min(this._fetch(), expr);\n    }\n\n    /**\n     * Applies a function to each document in a cursor and collects the return values in an array.\n     * @param callback\n     * @returns {Array}\n     */\n\n  }, {\n    key: 'map',\n    value: function map$$1(callback) {\n      return this._fetch().map(callback);\n    }\n\n    /**\n     * Applies a JavaScript function for every document in a cursor.\n     * @param callback\n     */\n\n  }, {\n    key: 'forEach',\n    value: function forEach(callback) {\n      each(this._fetch(), callback);\n    }\n\n    /**\n     * Applies an [ES2015 Iteration protocol][] compatible implementation\n     * [ES2015 Iteration protocol]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\n     * @returns {Object}\n     */\n\n  }, {\n    key: Symbol.iterator,\n    value: function value() {\n      var self = this;\n      return {\n        next: function next() {\n          if (!self.hasNext()) {\n            return { done: true };\n          }\n          return {\n            done: false,\n            value: self.next()\n          };\n        }\n      };\n    }\n  }]);\n  return Cursor;\n}();\n\n/**\n * Query and Projection Operators. https://docs.mongodb.com/manual/reference/operator/query/\n */\nvar simpleOperators = {\n\n  /**\n   * Checks that two values are equal.\n   *\n   * @param a         The lhs operand as resolved from the object by the given selector\n   * @param b         The rhs operand provided by the user\n   * @returns {*}\n   */\n  $eq: function $eq(a, b) {\n    // start with simple equality check\n    if (isEqual(a, b)) return true;\n\n    // https://docs.mongodb.com/manual/tutorial/query-for-null-fields/\n    if (isNil(a) && isNil(b)) return true;\n\n    if (isArray(a)) {\n      // is multi-valued lhs so we check each separately\n      if (hasMeta(a, { isMulti: true })) {\n        try {\n          for (var i = 0; i < a.length; i++) {\n            if (this.$eq(a[i], b)) {\n              return true;\n            }\n          }\n        } finally {\n          dropMeta(a);\n        }\n      } else {\n        // check one level deep\n        return a.findIndex(isEqual.bind(null, b)) !== -1;\n      }\n    }\n    return false;\n  },\n\n\n  /**\n   * Matches all values that are not equal to the value specified in the query.\n   *\n   * @param a\n   * @param b\n   * @returns {boolean}\n   */\n  $ne: function $ne(a, b) {\n    return !this.$eq(a, b);\n  },\n\n\n  /**\n   * Matches any of the values that exist in an array specified in the query.\n   *\n   * @param a\n   * @param b\n   * @returns {*}\n   */\n  $in: function $in(a, b) {\n    a = array(a);\n    return intersection(a, b).length > 0;\n  },\n\n\n  /**\n   * Matches values that do not exist in an array specified to the query.\n   *\n   * @param a\n   * @param b\n   * @returns {*|boolean}\n   */\n  $nin: function $nin(a, b) {\n    return isNil(a) || !this.$in(a, b);\n  },\n\n\n  /**\n   * Matches values that are less than the value specified in the query.\n   *\n   * @param a\n   * @param b\n   * @returns {boolean}\n   */\n  $lt: function $lt(a, b) {\n    a = array(a).find(function (val) {\n      return val < b;\n    });\n    return a !== undefined;\n  },\n\n\n  /**\n   * Matches values that are less than or equal to the value specified in the query.\n   *\n   * @param a\n   * @param b\n   * @returns {boolean}\n   */\n  $lte: function $lte(a, b) {\n    a = array(a).find(function (val) {\n      return val <= b;\n    });\n    return a !== undefined;\n  },\n\n\n  /**\n   * Matches values that are greater than the value specified in the query.\n   *\n   * @param a\n   * @param b\n   * @returns {boolean}\n   */\n  $gt: function $gt(a, b) {\n    a = array(a).find(function (val) {\n      return val > b;\n    });\n    return a !== undefined;\n  },\n\n\n  /**\n   * Matches values that are greater than or equal to the value specified in the query.\n   *\n   * @param a\n   * @param b\n   * @returns {boolean}\n   */\n  $gte: function $gte(a, b) {\n    a = array(a).find(function (val) {\n      return val >= b;\n    });\n    return a !== undefined;\n  },\n\n\n  /**\n   * Performs a modulo operation on the value of a field and selects documents with a specified result.\n   *\n   * @param a\n   * @param b\n   * @returns {boolean}\n   */\n  $mod: function $mod(a, b) {\n    a = array(a).find(function (val) {\n      return isNumber(val) && isArray(b) && b.length === 2 && val % b[0] === b[1];\n    });\n    return a !== undefined;\n  },\n\n\n  /**\n   * Selects documents where values match a specified regular expression.\n   *\n   * @param a\n   * @param b\n   * @returns {boolean}\n   */\n  $regex: function $regex(a, b) {\n    a = array(a).find(function (val) {\n      return isString(val) && isRegExp(b) && !!val.match(b);\n    });\n    return a !== undefined;\n  },\n\n\n  /**\n   * Matches documents that have the specified field.\n   *\n   * @param a\n   * @param b\n   * @returns {boolean}\n   */\n  $exists: function $exists(a, b) {\n    return (b === false || b === 0) && isNil(a) || (b === true || b === 1) && !isNil(a);\n  },\n\n\n  /**\n   * Matches arrays that contain all elements specified in the query.\n   *\n   * @param a\n   * @param b\n   * @returns boolean\n   */\n  $all: function $all(a, b) {\n    var matched = false;\n    if (isArray(a) && isArray(b)) {\n      for (var i = 0, len = b.length; i < len; i++) {\n        if (isObject(b[i]) && inArray(keys(b[i]), '$elemMatch')) {\n          matched = matched || this.$elemMatch(a, b[i].$elemMatch);\n        } else {\n          // order of arguments matter\n          return intersection(b, a).length === len;\n        }\n      }\n    }\n    return matched;\n  },\n\n\n  /**\n   * Selects documents if the array field is a specified size.\n   *\n   * @param a\n   * @param b\n   * @returns {*|boolean}\n   */\n  $size: function $size(a, b) {\n    return isArray(a) && isNumber(b) && a.length === b;\n  },\n\n\n  /**\n   * Selects documents if element in the array field matches all the specified $elemMatch condition.\n   *\n   * @param a\n   * @param b\n   */\n  $elemMatch: function $elemMatch(a, b) {\n    if (isArray(a) && !isEmpty(a)) {\n      var query = new Query(b);\n      for (var i = 0, len = a.length; i < len; i++) {\n        if (query.test(a[i])) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n\n\n  /**\n   * Selects documents if a field is of the specified type.\n   *\n   * @param a\n   * @param b\n   * @returns {boolean}\n   */\n  $type: function $type(a, b) {\n    switch (b) {\n      case 1:\n      case 'double':\n        return isNumber(a) && (a + '').indexOf('.') !== -1;\n      case 2:\n      case T_STRING:\n        return isString(a);\n      case 3:\n      case T_OBJECT:\n        return isObject(a);\n      case 4:\n      case T_ARRAY:\n        return isArray(a);\n      case 6:\n      case T_UNDEFINED:\n        return isNil(a);\n      case 8:\n      case T_BOOL:\n        return isBoolean(a);\n      case 9:\n      case T_DATE:\n        return isDate(a);\n      case 10:\n      case T_NULL:\n        return isNull(a);\n      case 11:\n      case T_REGEX:\n        return isRegExp(a);\n      case 16:\n      case 'int':\n        return isNumber(a) && a <= 2147483647 && (a + '').indexOf('.') === -1;\n      case 18:\n      case 'long':\n        return isNumber(a) && a > 2147483647 && a <= 9223372036854775807 && (a + '').indexOf('.') === -1;\n      case 19:\n      case 'decimal':\n        return isNumber(a);\n      default:\n        return false;\n    }\n  }\n};\n\nvar queryOperators = {\n\n  /**\n   * Joins query clauses with a logical AND returns all documents that match the conditions of both clauses.\n   *\n   * @param selector\n   * @param value\n   * @returns {{test: Function}}\n   */\n  $and: function $and(selector, value) {\n    assert(isArray(value), 'Invalid expression: $and expects value to be an Array');\n\n    var queries = [];\n    each(value, function (expr) {\n      return queries.push(new Query(expr));\n    });\n\n    return {\n      test: function test(obj) {\n        for (var i = 0; i < queries.length; i++) {\n          if (!queries[i].test(obj)) {\n            return false;\n          }\n        }\n        return true;\n      }\n    };\n  },\n\n\n  /**\n   * Joins query clauses with a logical OR returns all documents that match the conditions of either clause.\n   *\n   * @param selector\n   * @param value\n   * @returns {{test: Function}}\n   */\n  $or: function $or(selector, value) {\n    assert(isArray(value), 'Invalid expression. $or expects value to be an Array');\n\n    var queries = [];\n    each(value, function (expr) {\n      return queries.push(new Query(expr));\n    });\n\n    return {\n      test: function test(obj) {\n        for (var i = 0; i < queries.length; i++) {\n          if (queries[i].test(obj)) {\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n  },\n\n\n  /**\n   * Joins query clauses with a logical NOR returns all documents that fail to match both clauses.\n   *\n   * @param selector\n   * @param value\n   * @returns {{test: Function}}\n   */\n  $nor: function $nor(selector, value) {\n    assert(isArray(value), 'Invalid expression. $nor expects value to be an Array');\n    var query = this.$or('$or', value);\n    return {\n      test: function test(obj) {\n        return !query.test(obj);\n      }\n    };\n  },\n\n\n  /**\n   * Inverts the effect of a query expression and returns documents that do not match the query expression.\n   *\n   * @param selector\n   * @param value\n   * @returns {{test: Function}}\n   */\n  $not: function $not(selector, value) {\n    var criteria = {};\n    criteria[selector] = normalize(value);\n    var query = new Query(criteria);\n    return {\n      test: function test(obj) {\n        return !query.test(obj);\n      }\n    };\n  },\n\n\n  /**\n   * Matches documents that satisfy a JavaScript expression.\n   *\n   * @param selector\n   * @param value\n   * @returns {{test: test}}\n   */\n  $where: function $where(selector, value) {\n    if (!isFunction(value)) {\n      value = new Function('return ' + value + ';');\n    }\n    return {\n      test: function test(obj) {\n        return value.call(obj) === true;\n      }\n    };\n  }\n};\n\n// add simple query operators\neach(simpleOperators, function (fn, op) {\n  queryOperators[op] = function (f, ctx) {\n    return function (selector, value) {\n      return {\n        test: function test(obj) {\n          // value of field must be fully resolved.\n          var lhs = resolve(obj, selector);\n          return f.call(ctx, lhs, value);\n        }\n      };\n    };\n  }(fn, simpleOperators);\n});\n\n/**\n * Query object to test collection elements with\n * @param criteria the pass criteria for the query\n * @param projection optional projection specifiers\n * @constructor\n */\nvar Query = function () {\n  function Query(criteria) {\n    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, Query);\n\n    this.__criteria = criteria;\n    this.__projection = projection;\n    this.__compiled = [];\n    this._compile();\n  }\n\n  createClass(Query, [{\n    key: '_compile',\n    value: function _compile() {\n      var _this = this;\n\n      if (isEmpty(this.__criteria)) return;\n\n      assert(isObject(this.__criteria), 'Criteria must be of type Object');\n\n      var whereOperator = void 0;\n\n      each(this.__criteria, function (expr, field) {\n        // save $where operators to be executed after other operators\n        if ('$where' === field) {\n          whereOperator = { field: field, expr: expr };\n        } else if (inArray(['$and', '$or', '$nor'], field)) {\n          _this._processOperator(field, field, expr);\n        } else {\n          // normalize expression\n          expr = normalize(expr);\n          each(expr, function (val, op) {\n            _this._processOperator(field, op, val);\n          });\n        }\n\n        if (isObject(whereOperator)) {\n          _this._processOperator(whereOperator.field, whereOperator.field, whereOperator.expr);\n        }\n      });\n    }\n  }, {\n    key: '_processOperator',\n    value: function _processOperator(field, operator, value) {\n      if (inArray(ops(OP_QUERY), operator)) {\n        this.__compiled.push(queryOperators[operator](field, value));\n      } else {\n        err(\"Invalid query operator '\" + operator + \"' detected\");\n      }\n    }\n\n    /**\n     * Checks if the object passes the query criteria. Returns true if so, false otherwise.\n     * @param obj\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'test',\n    value: function test(obj) {\n      for (var i = 0, len = this.__compiled.length; i < len; i++) {\n        if (!this.__compiled[i].test(obj)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Performs a query on a collection and returns a cursor object.\n     * @param collection\n     * @param projection\n     * @returns {Cursor}\n     */\n\n  }, {\n    key: 'find',\n    value: function find(collection, projection) {\n      return new Cursor(collection, this, projection);\n    }\n\n    /**\n     * Remove matched documents from the collection returning the remainder\n     * @param collection\n     * @returns {Array}\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(collection) {\n      var _this2 = this;\n\n      return reduce(collection, function (acc, obj) {\n        if (!_this2.test(obj)) acc.push(obj);\n        return acc;\n      }, []);\n    }\n  }]);\n  return Query;\n}();\n\n/**\n * Performs a query on a collection and returns a cursor object.\n *\n * @param collection\n * @param criteria\n * @param projection\n * @returns {Cursor}\n */\nfunction find(collection, criteria, projection) {\n  return new Query(criteria).find(collection, projection);\n}\n\n/**\n * Returns a new array without objects which match the criteria\n *\n * @param collection\n * @param criteria\n * @returns {Array}\n */\nfunction remove(collection, criteria) {\n  return new Query(criteria).remove(collection);\n}\n\nvar arithmeticOperators = {\n\n  /**\n   * Returns the absolute value of a number.\n   * https://docs.mongodb.com/manual/reference/operator/aggregation/abs/#exp._S_abs\n   * @param obj\n   * @param expr\n   * @return {Number|null|NaN}\n   */\n  $abs: function $abs(obj, expr) {\n    var val = computeValue(obj, expr);\n    return val === null || val === undefined ? null : Math.abs(val);\n  },\n\n\n  /**\n   * Computes the sum of an array of numbers.\n   *\n   * @param obj\n   * @param expr\n   * @returns {Object}\n   */\n  $add: function $add(obj, expr) {\n    var args = computeValue(obj, expr);\n    return reduce(args, function (acc, num) {\n      return acc + num;\n    }, 0);\n  },\n\n\n  /**\n   * Returns the smallest integer greater than or equal to the specified number.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $ceil: function $ceil(obj, expr) {\n    var arg = computeValue(obj, expr);\n    if (isNaN(arg)) return NaN;\n    if (isNil(arg)) return null;\n    assert(isNumber(arg), '$ceil must be a valid expression that resolves to a number.');\n    return Math.ceil(arg);\n  },\n\n\n  /**\n   * Takes two numbers and divides the first number by the second.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $divide: function $divide(obj, expr) {\n    var args = computeValue(obj, expr);\n    return args[0] / args[1];\n  },\n\n\n  /**\n   * Raises Euler’s number (i.e. e ) to the specified exponent and returns the result.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $exp: function $exp(obj, expr) {\n    var arg = computeValue(obj, expr);\n    if (isNaN(arg)) return NaN;\n    if (isNil(arg)) return null;\n    assert(isNumber(arg), '$exp must be a valid expression that resolves to a number.');\n    return Math.exp(arg);\n  },\n\n\n  /**\n   * Returns the largest integer less than or equal to the specified number.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $floor: function $floor(obj, expr) {\n    var arg = computeValue(obj, expr);\n    if (isNaN(arg)) return NaN;\n    if (isNil(arg)) return null;\n    assert(isNumber(arg), '$floor must be a valid expression that resolves to a number.');\n    return Math.floor(arg);\n  },\n\n\n  /**\n   * Calculates the natural logarithm ln (i.e loge) of a number and returns the result as a double.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $ln: function $ln(obj, expr) {\n    var arg = computeValue(obj, expr);\n    if (isNaN(arg)) return NaN;\n    if (isNil(arg)) return null;\n    assert(isNumber(arg), '$ln must be a valid expression that resolves to a number.');\n    return Math.log(arg);\n  },\n\n\n  /**\n   * Calculates the log of a number in the specified base and returns the result as a double.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $log: function $log(obj, expr) {\n    var args = computeValue(obj, expr);\n    assert(isArray(args) && args.length === 2, '$log must be a valid expression that resolves to an array of 2 items');\n    if (args.some(isNaN)) return NaN;\n    if (args.some(isNil)) return null;\n    assert(args.every(isNumber), '$log expression must resolve to array of 2 numbers');\n    return Math.log10(args[0]) / Math.log10(args[1]);\n  },\n\n\n  /**\n   * Calculates the log base 10 of a number and returns the result as a double.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $log10: function $log10(obj, expr) {\n    var arg = computeValue(obj, expr);\n    if (isNaN(arg)) return NaN;\n    if (isNil(arg)) return null;\n    assert(isNumber(arg), '$log10 must be a valid expression that resolves to a number.');\n    return Math.log10(arg);\n  },\n\n\n  /**\n   * Takes two numbers and calculates the modulo of the first number divided by the second.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $mod: function $mod(obj, expr) {\n    var args = computeValue(obj, expr);\n    return args[0] % args[1];\n  },\n\n\n  /**\n   * Computes the product of an array of numbers.\n   *\n   * @param obj\n   * @param expr\n   * @returns {Object}\n   */\n  $multiply: function $multiply(obj, expr) {\n    var args = computeValue(obj, expr);\n    return reduce(args, function (acc, num) {\n      return acc * num;\n    }, 1);\n  },\n\n\n  /**\n   * Raises a number to the specified exponent and returns the result.\n   *\n   * @param obj\n   * @param expr\n   * @returns {Object}\n   */\n  $pow: function $pow(obj, expr) {\n    var args = computeValue(obj, expr);\n\n    assert(isArray(args) && args.length === 2 && args.every(isNumber), '$pow expression must resolve to an array of 2 numbers');\n    assert(!(args[0] === 0 && args[1] < 0), '$pow cannot raise 0 to a negative exponent');\n\n    return Math.pow(args[0], args[1]);\n  },\n\n\n  /**\n   * Calculates the square root of a positive number and returns the result as a double.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $sqrt: function $sqrt(obj, expr) {\n    var n = computeValue(obj, expr);\n    if (isNaN(n)) return NaN;\n    if (isNil(n)) return null;\n    assert(isNumber(n) && n > 0, '$sqrt expression must resolve to non-negative number.');\n    return Math.sqrt(n);\n  },\n\n\n  /**\n   * Takes an array that contains two numbers or two dates and subtracts the second value from the first.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $subtract: function $subtract(obj, expr) {\n    var args = computeValue(obj, expr);\n    return args[0] - args[1];\n  },\n\n\n  /**\n   * Truncates a number to its integer.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $trunc: function $trunc(obj, expr) {\n    var n = computeValue(obj, expr);\n    if (isNaN(n)) return NaN;\n    if (isNil(n)) return null;\n    assert(isNumber(n) && n > 0, '$trunc must be a valid expression that resolves to a non-negative number.');\n    return Math.trunc(n);\n  }\n};\n\nvar arrayOperators = {\n  /**\n   * Returns the element at the specified array index.\n   *\n   * @param  {Object} obj\n   * @param  {*} expr\n   * @return {*}\n   */\n  $arrayElemAt: function $arrayElemAt(obj, expr) {\n    var arr = computeValue(obj, expr);\n    assert(isArray(arr) && arr.length === 2, '$arrayElemAt expression must resolve to an array of 2 elements');\n    assert(isArray(arr[0]), 'First operand to $arrayElemAt must resolve to an array');\n    assert(isNumber(arr[1]), 'Second operand to $arrayElemAt must resolve to an integer');\n    var idx = arr[1];\n    arr = arr[0];\n    if (idx < 0 && Math.abs(idx) <= arr.length) {\n      return arr[idx + arr.length];\n    } else if (idx >= 0 && idx < arr.length) {\n      return arr[idx];\n    }\n    return undefined;\n  },\n\n\n  /**\n   * Converts an array of key value pairs to a document.\n   */\n  $arrayToObject: function $arrayToObject(obj, expr) {\n    var arr = computeValue(obj, expr);\n    assert(isArray(arr), '$arrayToObject expression must resolve to an array');\n    return reduce(arr, function (newObj, val) {\n      if (isArray(val) && val.length == 2) newObj[val[0]] = val[1];else if (isObject(val) && has(val, 'k') && has(val, 'v')) newObj[val.k] = val.v;else err('$arrayToObject expression is invalid.');\n      return newObj;\n    }, {});\n  },\n\n\n  /**\n   * Concatenates arrays to return the concatenated array.\n   *\n   * @param  {Object} obj\n   * @param  {*} expr\n   * @return {*}\n   */\n  $concatArrays: function $concatArrays(obj, expr) {\n    var arr = computeValue(obj, expr, null);\n    assert(isArray(arr) && arr.length === 2, '$concatArrays expression must resolve to an array of 2 elements');\n\n    if (arr.some(isNil)) return null;\n\n    return arr[0].concat(arr[1]);\n  },\n\n\n  /**\n   * Selects a subset of the array to return an array with only the elements that match the filter condition.\n   *\n   * @param  {Object} obj  [description]\n   * @param  {*} expr [description]\n   * @return {*}      [description]\n   */\n  $filter: function $filter(obj, expr) {\n    var input = computeValue(obj, expr.input);\n    var asVar = expr['as'];\n    var condExpr = expr['cond'];\n\n    assert(isArray(input), \"$filter 'input' expression must resolve to an array\");\n\n    return input.filter(function (o) {\n      // inject variable\n      var tempObj = {};\n      tempObj['$' + asVar] = o;\n      return computeValue(tempObj, condExpr) === true;\n    });\n  },\n\n\n  /**\n   * Returns a boolean indicating whether a specified value is in an array.\n   *\n   * @param {Object} obj\n   * @param {Array} expr\n   */\n  $in: function $in(obj, expr) {\n    var val = computeValue(obj, expr[0]);\n    var arr = computeValue(obj, expr[1]);\n    assert(isArray(arr), '$in second argument must be an array');\n    return inArray(arr, val);\n  },\n\n\n  /**\n   * Searches an array for an occurrence of a specified value and returns the array index of the first occurrence.\n   * If the substring is not found, returns -1.\n   *\n   * @param  {Object} obj\n   * @param  {*} expr\n   * @return {*}\n   */\n  $indexOfArray: function $indexOfArray(obj, expr) {\n    var args = computeValue(obj, expr);\n    if (isNil(args)) return null;\n\n    var arr = args[0];\n    if (isNil(arr)) return null;\n\n    assert(isArray(arr), '$indexOfArray expression must resolve to an array.');\n\n    var searchValue = args[1];\n    if (isNil(searchValue)) return null;\n\n    var start = args[2] || 0;\n    var end = args[3] || arr.length;\n\n    if (end < arr.length) {\n      arr = arr.slice(start, end);\n    }\n\n    return arr.indexOf(searchValue, start);\n  },\n\n\n  /**\n   * Determines if the operand is an array. Returns a boolean.\n   *\n   * @param  {Object}  obj\n   * @param  {*}  expr\n   * @return {Boolean}\n   */\n  $isArray: function $isArray(obj, expr) {\n    return isArray(computeValue(obj, expr));\n  },\n\n\n  /**\n   * Applies a sub-expression to each element of an array and returns the array of resulting values in order.\n   *\n   * @param obj\n   * @param expr\n   * @returns {Array|*}\n   */\n  $map: function $map(obj, expr) {\n    var inputExpr = computeValue(obj, expr.input);\n    assert(isArray(inputExpr), '$map \\'input\\' expression must resolve to an array');\n\n    var asExpr = expr['as'];\n    var inExpr = expr['in'];\n\n    // HACK: add the \"as\" expression as a value on the object to take advantage of \"resolve()\"\n    // which will reduce to that value when invoked. The reference to the as expression will be prefixed with \"$$\".\n    // But since a \"$\" is stripped of before passing the name to \"resolve()\" we just need to prepend \"$\" to the key.\n    var tempKey = '$' + asExpr;\n    // let's save any value that existed, kinda useless but YOU CAN NEVER BE TOO SURE, CAN YOU :)\n    var original = obj[tempKey];\n    return map(inputExpr, function (item) {\n      obj[tempKey] = item;\n      var value = computeValue(obj, inExpr);\n      // cleanup and restore\n      if (isUndefined(original)) {\n        delete obj[tempKey];\n      } else {\n        obj[tempKey] = original;\n      }\n      return value;\n    });\n  },\n\n\n  /**\n   * Converts a document to an array of documents representing key-value pairs.\n   */\n  $objectToArray: function $objectToArray(obj, expr) {\n    var val = computeValue(obj, expr);\n    assert(isObject(val), '$objectToArray expression must resolve to an object');\n    var arr = [];\n    each(val, function (v, k) {\n      return arr.push({ k: k, v: v });\n    });\n    return arr;\n  },\n\n\n  /**\n   * Returns an array whose elements are a generated sequence of numbers.\n   *\n   * @param  {Object} obj\n   * @param  {*} expr\n   * @return {*}\n   */\n  $range: function $range(obj, expr) {\n    var arr = computeValue(obj, expr);\n    var start = arr[0];\n    var end = arr[1];\n    var step = arr[2] || 1;\n\n    var result = [];\n\n    while (start < end && step > 0 || start > end && step < 0) {\n      result.push(start);\n      start += step;\n    }\n\n    return result;\n  },\n\n\n  /**\n   * Applies an expression to each element in an array and combines them into a single value.\n   *\n   * @param {Object} obj\n   * @param {*} expr\n   */\n  $reduce: function $reduce(obj, expr) {\n    var input = computeValue(obj, expr.input);\n    var initialValue = computeValue(obj, expr.initialValue);\n    var inExpr = expr['in'];\n\n    if (isNil(input)) return null;\n    assert(isArray(input), \"$reduce 'input' expression must resolve to an array\");\n    return reduce(input, function (acc, n) {\n      return computeValue({ '$value': acc, '$this': n }, inExpr);\n    }, initialValue);\n  },\n\n\n  /**\n   * Returns an array with the elements in reverse order.\n   *\n   * @param  {Object} obj\n   * @param  {*} expr\n   * @return {*}\n   */\n  $reverseArray: function $reverseArray(obj, expr) {\n    var arr = computeValue(obj, expr);\n\n    if (isNil(arr)) return null;\n    assert(isArray(arr), '$reverseArray expression must resolve to an array');\n\n    var result = [];\n    into(result, arr);\n    result.reverse();\n    return result;\n  },\n\n\n  /**\n   * Counts and returns the total the number of items in an array.\n   *\n   * @param obj\n   * @param expr\n   */\n  $size: function $size(obj, expr) {\n    var value = computeValue(obj, expr);\n    return isArray(value) ? value.length : undefined;\n  },\n\n\n  /**\n   * Returns a subset of an array.\n   *\n   * @param  {Object} obj\n   * @param  {*} expr\n   * @return {*}\n   */\n  $slice: function $slice(obj, expr) {\n    var arr = computeValue(obj, expr);\n    return slice(arr[0], arr[1], arr[2]);\n  },\n\n\n  /**\n   * Merge two lists together.\n   *\n   * Transposes an array of input arrays so that the first element of the output array would be an array containing,\n   * the first element of the first input array, the first element of the second input array, etc.\n   *\n   * @param  {Obj} obj\n   * @param  {*} expr\n   * @return {*}\n   */\n  $zip: function $zip(obj, expr) {\n    var inputs = computeValue(obj, expr.inputs);\n    var useLongestLength = expr.useLongestLength || false;\n\n    assert(isArray(inputs), \"'inputs' expression must resolve to an array\");\n    assert(isBoolean(useLongestLength), \"'useLongestLength' must be a boolean\");\n\n    if (isArray(expr.defaults)) {\n      assert(truthy(useLongestLength), \"'useLongestLength' must be set to true to use 'defaults'\");\n    }\n\n    var zipCount = 0;\n\n    for (var i = 0, len = inputs.length; i < len; i++) {\n      var arr = inputs[i];\n\n      if (isNil(arr)) return null;\n\n      assert(isArray(arr), \"'inputs' expression values must resolve to an array or null\");\n\n      zipCount = useLongestLength ? Math.max(zipCount, arr.length) : Math.min(zipCount || arr.length, arr.length);\n    }\n\n    var result = [];\n    var defaults = expr.defaults || [];\n\n    var _loop = function _loop(_i) {\n      var temp = inputs.map(function (val, index) {\n        return isNil(val[_i]) ? defaults[index] || null : val[_i];\n      });\n      result.push(temp);\n    };\n\n    for (var _i = 0; _i < zipCount; _i++) {\n      _loop(_i);\n    }\n\n    return result;\n  }\n};\n\nvar booleanOperators = {\n  /**\n   * Returns true only when all its expressions evaluate to true. Accepts any number of argument expressions.\n   *\n   * @param obj\n   * @param expr\n   * @returns {boolean}\n   */\n  $and: function $and(obj, expr) {\n    var value = computeValue(obj, expr);\n    return truthy(value) && value.every(truthy);\n  },\n\n  /**\n   * Returns true when any of its expressions evaluates to true. Accepts any number of argument expressions.\n   *\n   * @param obj\n   * @param expr\n   * @returns {boolean}\n   */\n  $or: function $or(obj, expr) {\n    var value = computeValue(obj, expr);\n    return truthy(value) && value.some(truthy);\n  },\n\n  /**\n   * Returns the boolean value that is the opposite of its argument expression. Accepts a single argument expression.\n   *\n   * @param obj\n   * @param expr\n   * @returns {boolean}\n   */\n  $not: function $not(obj, expr) {\n    return !computeValue(obj, expr[0]);\n  }\n};\n\nvar comparisonOperators = {\n  /**\n   * Compares two values and returns the result of the comparison as an integer.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $cmp: function $cmp(obj, expr) {\n    var args = computeValue(obj, expr);\n    if (args[0] > args[1]) return 1;\n    if (args[0] < args[1]) return -1;\n    return 0;\n  }\n};\n// mixin comparison operators\neach(['$eq', '$ne', '$gt', '$gte', '$lt', '$lte', '$in', '$nin'], function (op) {\n  comparisonOperators[op] = function (obj, expr) {\n    var args = computeValue(obj, expr);\n    return simpleOperators[op](args[0], args[1]);\n  };\n});\n\n/**\n * Conditional operators\n */\n\nvar conditionalOperators = {\n\n  /**\n   * A ternary operator that evaluates one expression,\n   * and depending on the result returns the value of one following expressions.\n   *\n   * @param obj\n   * @param expr\n   */\n  $cond: function $cond(obj, expr) {\n    var ifExpr = void 0,\n        thenExpr = void 0,\n        elseExpr = void 0;\n    if (isArray(expr)) {\n      assert(expr.length === 3, 'Invalid arguments for $cond operator');\n      ifExpr = expr[0];\n      thenExpr = expr[1];\n      elseExpr = expr[2];\n    } else if (isObject(expr)) {\n      ifExpr = expr['if'];\n      thenExpr = expr['then'];\n      elseExpr = expr['else'];\n    }\n    var condition = computeValue(obj, ifExpr);\n    return condition ? computeValue(obj, thenExpr, null) : computeValue(obj, elseExpr);\n  },\n\n\n  /**\n   * An operator that evaluates a series of case expressions. When it finds an expression which\n   * evaluates to true, it returns the resulting expression for that case. If none of the cases\n   * evaluate to true, it returns the default expression.\n   *\n   * @param obj\n   * @param expr\n   */\n  $switch: function $switch(obj, expr) {\n    assert(expr.branches, 'Invalid arguments for $switch operator');\n\n    var validBranch = expr.branches.find(function (branch) {\n      assert(branch['case'] && branch['then'], 'Invalid arguments for $switch operator');\n      return computeValue(obj, branch['case']);\n    });\n\n    if (validBranch) {\n      return computeValue(obj, validBranch.then);\n    } else if (!expr.default) {\n      err('Invalid arguments for $switch operator');\n    } else {\n      return computeValue(obj, expr.default);\n    }\n  },\n\n\n  /**\n   * Evaluates an expression and returns the first expression if it evaluates to a non-null value.\n   * Otherwise, $ifNull returns the second expression's value.\n   *\n   * @param obj\n   * @param expr\n   * @returns {*}\n   */\n  $ifNull: function $ifNull(obj, expr) {\n    assert(isArray(expr) && expr.length === 2, 'Invalid arguments for $ifNull operator');\n    var args = computeValue(obj, expr);\n    return args[0] === null || args[0] === undefined ? args[1] : args[0];\n  }\n};\n\n// used for formatting dates in $dateToString operator\nvar DATE_SYM_TABLE = {\n  '%Y': ['$year', 4],\n  '%m': ['$month', 2],\n  '%d': ['$dayOfMonth', 2],\n  '%H': ['$hour', 2],\n  '%M': ['$minute', 2],\n  '%S': ['$second', 2],\n  '%L': ['$millisecond', 3],\n  '%j': ['$dayOfYear', 3],\n  '%w': ['$dayOfWeek', 1],\n  '%U': ['$week', 2],\n  '%%': '%'\n};\n\nvar dateOperators = {\n  /**\n   * Returns the day of the year for a date as a number between 1 and 366 (leap year).\n   * @param obj\n   * @param expr\n   */\n  $dayOfYear: function $dayOfYear(obj, expr) {\n    var d = computeValue(obj, expr);\n    if (isDate(d)) {\n      var start = new Date(d.getFullYear(), 0, 0);\n      var diff = d - start;\n      var oneDay = 1000 * 60 * 60 * 24;\n      return Math.round(diff / oneDay);\n    }\n    return undefined;\n  },\n\n\n  /**\n   * Returns the day of the month for a date as a number between 1 and 31.\n   * @param obj\n   * @param expr\n   */\n  $dayOfMonth: function $dayOfMonth(obj, expr) {\n    var d = computeValue(obj, expr);\n    return isDate(d) ? d.getDate() : undefined;\n  },\n\n\n  /**\n   * Returns the day of the week for a date as a number between 1 (Sunday) and 7 (Saturday).\n   * @param obj\n   * @param expr\n   */\n  $dayOfWeek: function $dayOfWeek(obj, expr) {\n    var d = computeValue(obj, expr);\n    return isDate(d) ? d.getDay() + 1 : undefined;\n  },\n\n\n  /**\n   * Returns the year for a date as a number (e.g. 2014).\n   * @param obj\n   * @param expr\n   */\n  $year: function $year(obj, expr) {\n    var d = computeValue(obj, expr);\n    return isDate(d) ? d.getFullYear() : undefined;\n  },\n\n\n  /**\n   * Returns the month for a date as a number between 1 (January) and 12 (December).\n   * @param obj\n   * @param expr\n   */\n  $month: function $month(obj, expr) {\n    var d = computeValue(obj, expr);\n    return isDate(d) ? d.getMonth() + 1 : undefined;\n  },\n\n\n  /**\n   * Returns the week number for a date as a number between 0\n   * (the partial week that precedes the first Sunday of the year) and 53 (leap year).\n   * @param obj\n   * @param expr\n   */\n  $week: function $week(obj, expr) {\n    // source: http://stackoverflow.com/a/6117889/1370481\n    var d = computeValue(obj, expr);\n\n    // Copy date so don't modify original\n    d = new Date(+d);\n    d.setHours(0, 0, 0);\n    // Set to nearest Thursday: current date + 4 - current day number\n    // Make Sunday's day number 7\n    d.setDate(d.getDate() + 4 - (d.getDay() || 7));\n    // Get first day of year\n    var yearStart = new Date(d.getFullYear(), 0, 1);\n    // Calculate full weeks to nearest Thursday\n    return Math.floor(((d - yearStart) / 8.64e7 + 1) / 7);\n  },\n\n\n  /**\n   * Returns the hour for a date as a number between 0 and 23.\n   * @param obj\n   * @param expr\n   */\n  $hour: function $hour(obj, expr) {\n    var d = computeValue(obj, expr);\n    return isDate(d) ? d.getUTCHours() : undefined;\n  },\n\n\n  /**\n   * Returns the minute for a date as a number between 0 and 59.\n   * @param obj\n   * @param expr\n   */\n  $minute: function $minute(obj, expr) {\n    var d = computeValue(obj, expr);\n    return isDate(d) ? d.getMinutes() : undefined;\n  },\n\n\n  /**\n   * Returns the seconds for a date as a number between 0 and 60 (leap seconds).\n   * @param obj\n   * @param expr\n   */\n  $second: function $second(obj, expr) {\n    var d = computeValue(obj, expr);\n    return isDate(d) ? d.getSeconds() : undefined;\n  },\n\n\n  /**\n   * Returns the milliseconds of a date as a number between 0 and 999.\n   * @param obj\n   * @param expr\n   */\n  $millisecond: function $millisecond(obj, expr) {\n    var d = computeValue(obj, expr);\n    return isDate(d) ? d.getMilliseconds() : undefined;\n  },\n\n\n  /**\n   * Returns the date as a formatted string.\n   *\n   * %Y  Year (4 digits, zero padded)  0000-9999\n   * %m  Month (2 digits, zero padded)  01-12\n   * %d  Day of Month (2 digits, zero padded)  01-31\n   * %H  Hour (2 digits, zero padded, 24-hour clock)  00-23\n   * %M  Minute (2 digits, zero padded)  00-59\n   * %S  Second (2 digits, zero padded)  00-60\n   * %L  Millisecond (3 digits, zero padded)  000-999\n   * %j  Day of year (3 digits, zero padded)  001-366\n   * %w  Day of week (1-Sunday, 7-Saturday)  1-7\n   * %U  Week of year (2 digits, zero padded)  00-53\n   * %%  Percent Character as a Literal  %\n   *\n   * @param obj current object\n   * @param expr operator expression\n   */\n  $dateToString: function $dateToString(obj, expr) {\n    var fmt = expr['format'];\n    var date = computeValue(obj, expr['date']);\n    var matches = fmt.match(/(%%|%Y|%m|%d|%H|%M|%S|%L|%j|%w|%U)/g);\n\n    for (var i = 0, len = matches.length; i < len; i++) {\n      var hdlr = DATE_SYM_TABLE[matches[i]];\n      var value = hdlr;\n\n      if (isArray(hdlr)) {\n        // reuse date operators\n        var fn = this[hdlr[0]];\n        var pad = hdlr[1];\n        value = padDigits(fn.call(this, obj, date), pad);\n      }\n      // replace the match with resolved value\n      fmt = fmt.replace(matches[i], value);\n    }\n\n    return fmt;\n  }\n};\n\nfunction padDigits(number, digits) {\n  return new Array(Math.max(digits - String(number).length + 1, 0)).join('0') + number;\n}\n\nvar literalOperators = {\n  /**\n   * Return a value without parsing.\n   * @param obj\n   * @param expr\n   */\n  $literal: function $literal(obj, expr) {\n    return expr;\n  }\n};\n\nvar setOperators = {\n  /**\n   * Returns true if two sets have the same elements.\n   * @param obj\n   * @param expr\n   */\n  $setEquals: function $setEquals(obj, expr) {\n    var args = computeValue(obj, expr);\n    var xs = unique(args[0]);\n    var ys = unique(args[1]);\n    return xs.length === ys.length && xs.length === intersection(xs, ys).length;\n  },\n\n\n  /**\n   * Returns the common elements of the input sets.\n   * @param obj\n   * @param expr\n   */\n  $setIntersection: function $setIntersection(obj, expr) {\n    var args = computeValue(obj, expr);\n    return intersection(args[0], args[1]);\n  },\n\n\n  /**\n   * Returns elements of a set that do not appear in a second set.\n   * @param obj\n   * @param expr\n   */\n  $setDifference: function $setDifference(obj, expr) {\n    var args = computeValue(obj, expr);\n    return args[0].filter(notInArray.bind(null, args[1]));\n  },\n\n\n  /**\n   * Returns a set that holds all elements of the input sets.\n   * @param obj\n   * @param expr\n   */\n  $setUnion: function $setUnion(obj, expr) {\n    var args = computeValue(obj, expr);\n    return union(args[0], args[1]);\n  },\n\n\n  /**\n   * Returns true if all elements of a set appear in a second set.\n   * @param obj\n   * @param expr\n   */\n  $setIsSubset: function $setIsSubset(obj, expr) {\n    var args = computeValue(obj, expr);\n    return intersection(args[0], args[1]).length === args[0].length;\n  },\n\n\n  /**\n   * Returns true if any elements of a set evaluate to true, and false otherwise.\n   * @param obj\n   * @param expr\n   */\n  $anyElementTrue: function $anyElementTrue(obj, expr) {\n    // mongodb nests the array expression in another\n    var args = computeValue(obj, expr)[0];\n    return args.some(truthy);\n  },\n\n\n  /**\n   * Returns true if all elements of a set evaluate to true, and false otherwise.\n   * @param obj\n   * @param expr\n   */\n  $allElementsTrue: function $allElementsTrue(obj, expr) {\n    // mongodb nests the array expression in another\n    var args = computeValue(obj, expr)[0];\n    return args.every(truthy);\n  }\n};\n\nvar stringOperators = {\n\n  /**\n   * Concatenates two strings.\n   *\n   * @param obj\n   * @param expr\n   * @returns {string|*}\n   */\n  $concat: function $concat(obj, expr) {\n    var args = computeValue(obj, expr);\n    // does not allow concatenation with nulls\n    if ([null, undefined].some(inArray.bind(null, args))) {\n      return null;\n    }\n    return args.join('');\n  },\n\n\n  /**\n   * Searches a string for an occurence of a substring and returns the UTF-8 code point index of the first occurence.\n   * If the substring is not found, returns -1.\n   *\n   * @param  {Object} obj\n   * @param  {*} expr\n   * @return {*}\n   */\n  $indexOfBytes: function $indexOfBytes(obj, expr) {\n    var arr = computeValue(obj, expr);\n\n    if (isNil(arr[0])) return null;\n\n    assert(isString(arr[0]), '$indexOfBytes first operand must resolve to a string');\n    assert(isString(arr[1]), '$indexOfBytes second operand must resolve to a string');\n\n    var str = arr[0];\n    var searchStr = arr[1];\n    var start = arr[2];\n    var end = arr[3];\n\n    assert(isNil(start) || isNumber(start) && start >= 0 && Math.round(start) === start, '$indexOfBytes third operand must resolve to a non-negative integer');\n    start = start || 0;\n\n    assert(isNil(end) || isNumber(end) && end >= 0 && Math.round(end) === end, '$indexOfBytes fourth operand must resolve to a non-negative integer');\n    end = end || str.length;\n\n    if (start > end) return -1;\n\n    var index = str.substring(start, end).indexOf(searchStr);\n    return index > -1 ? index + start : index;\n  },\n\n\n  /**\n   * Splits a string into substrings based on a delimiter.\n   * If the delimiter is not found within the string, returns an array containing the original string.\n   *\n   * @param  {Object} obj\n   * @param  {Array} expr\n   * @return {Array} Returns an array of substrings.\n   */\n  $split: function $split(obj, expr) {\n    var args = computeValue(obj, expr);\n    assert(isString(args[0]), '$split requires an expression that evaluates to a string as a first argument, found: ' + getType(args[0]));\n    assert(isString(args[1]), '$split requires an expression that evaluates to a string as a second argument, found: ' + getType(args[1]));\n    return args[0].split(args[1]);\n  },\n\n\n  /**\n   * Compares two strings and returns an integer that reflects the comparison.\n   *\n   * @param obj\n   * @param expr\n   * @returns {number}\n   */\n  $strcasecmp: function $strcasecmp(obj, expr) {\n    var args = computeValue(obj, expr);\n    args[0] = isEmpty(args[0]) ? '' : args[0].toUpperCase();\n    args[1] = isEmpty(args[1]) ? '' : args[1].toUpperCase();\n    if (args[0] > args[1]) {\n      return 1;\n    }\n    return args[0] < args[1] ? -1 : 0;\n  },\n\n\n  /**\n   * Returns a substring of a string, starting at a specified index position and including the specified number of characters.\n   * The index is zero-based.\n   *\n   * @param obj\n   * @param expr\n   * @returns {string}\n   */\n  $substr: function $substr(obj, expr) {\n    var args = computeValue(obj, expr);\n    if (isString(args[0])) {\n      if (args[1] < 0) {\n        return '';\n      } else if (args[2] < 0) {\n        return args[0].substr(args[1]);\n      } else {\n        return args[0].substr(args[1], args[2]);\n      }\n    }\n    return '';\n  },\n\n\n  /**\n   * Converts a string to lowercase.\n   *\n   * @param obj\n   * @param expr\n   * @returns {string}\n   */\n  $toLower: function $toLower(obj, expr) {\n    var value = computeValue(obj, expr);\n    return isEmpty(value) ? '' : value.toLowerCase();\n  },\n\n\n  /**\n   * Converts a string to uppercase.\n   *\n   * @param obj\n   * @param expr\n   * @returns {string}\n   */\n  $toUpper: function $toUpper(obj, expr) {\n    var value = computeValue(obj, expr);\n    return isEmpty(value) ? '' : value.toUpperCase();\n  }\n};\n\n/**\n * Aggregation framework variable operators\n */\n\nvar variableOperators = {\n  /**\n   * Defines variables for use within the scope of a sub-expression and returns the result of the sub-expression.\n   *\n   * @param obj\n   * @param expr\n   * @returns {*}\n   */\n  $let: function $let(obj, expr) {\n    var varsExpr = expr['vars'];\n    var inExpr = expr['in'];\n\n    // resolve vars\n    var originals = {};\n    var varsKeys = keys(varsExpr);\n    each(varsKeys, function (key) {\n      var val = computeValue(obj, varsExpr[key]);\n      var tempKey = '$' + key;\n      // set value on object using same technique as in \"$map\"\n      originals[tempKey] = obj[tempKey];\n      obj[tempKey] = val;\n    });\n\n    var value = computeValue(obj, inExpr);\n\n    // cleanup and restore\n    each(varsKeys, function (key) {\n      var tempKey = '$' + key;\n      if (isUndefined(originals[tempKey])) {\n        delete obj[tempKey];\n      } else {\n        obj[tempKey] = originals[tempKey];\n      }\n    });\n\n    return value;\n  }\n};\n\n// combine aggregate operators\nvar aggregateOperators = Object.assign({}, arithmeticOperators, arrayOperators, booleanOperators, comparisonOperators, conditionalOperators, dateOperators, literalOperators, setOperators, stringOperators, variableOperators);\n\n// operator definitions\nvar OPERATORS = {\n  'aggregate': aggregateOperators,\n  'group': groupOperators,\n  'pipeline': pipelineOperators,\n  'projection': projectionOperators,\n  'query': queryOperators\n\n  /**\n   * Returns the operators defined for the given operator classes\n   */\n};function ops() {\n  return reduce(arguments, function (acc, cls) {\n    return into(acc, keys(OPERATORS[cls]));\n  }, []);\n}\n\n/**\n * Add new operators\n *\n * @param opClass the operator class to extend\n * @param fn a function returning an object of new operators\n */\nfunction addOperators(opClass, fn) {\n\n  var newOperators = fn(_internal());\n\n  // ensure correct type specified\n  assert(has(OPERATORS, opClass), 'Invalid operator class ' + opClass);\n\n  var operators = OPERATORS[opClass];\n\n  // check for existing operators\n  each(newOperators, function (fn, op) {\n    assert(/^\\$\\w+$/.test(op), 'Invalid operator name ' + op);\n    assert(!has(operators, op), op + ' already exists for \\'' + opClass + '\\' operators');\n  });\n\n  var wrapped = {};\n\n  switch (opClass) {\n    case OP_QUERY:\n      each(newOperators, function (fn, op) {\n        wrapped[op] = function (f, ctx) {\n          return function (selector, value) {\n            return {\n              test: function test(obj) {\n                // value of field must be fully resolved.\n                var lhs = resolve(obj, selector);\n                var result = f.call(ctx, selector, lhs, value);\n                if (isBoolean(result)) {\n                  return result;\n                } else if (result instanceof Query) {\n                  return result.test(obj);\n                } else {\n                  err(\"Invalid return type for '\" + op + \"'. Must return a Boolean or Query\");\n                }\n              }\n            };\n          };\n        }(fn, newOperators);\n      });\n      break;\n    case OP_PROJECTION:\n      each(newOperators, function (fn, op) {\n        wrapped[op] = function (f, ctx) {\n          return function (obj, expr, selector) {\n            var lhs = resolve(obj, selector);\n            return f.call(ctx, selector, lhs, expr);\n          };\n        }(fn, newOperators);\n      });\n      break;\n    default:\n      each(newOperators, function (fn, op) {\n        wrapped[op] = function (f, ctx) {\n          return function () {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            return f.apply(ctx, args);\n          };\n        }(fn, newOperators);\n      });\n  }\n\n  // toss the operator salad :)\n  Object.assign(OPERATORS[opClass], wrapped);\n}\n\n/**\n * Internal functions\n */\n\n// Settings used by Mingo internally\nvar settings = {\n  key: '_id'\n\n  /**\n   * Setup default settings for Mingo\n   * @param options\n   */\n};function setup(options) {\n  Object.assign(settings, options || {});\n}\n\n/**\n * Implementation of system variables\n * @type {Object}\n */\nvar systemVariables = {\n  '$$ROOT': function $$ROOT(obj, expr, opt) {\n    return opt.root;\n  },\n  '$$CURRENT': function $$CURRENT(obj, expr, opt) {\n    return obj;\n  }\n};\n\n/**\n * Implementation of $redact variables\n *\n * Each function accepts 3 arguments (obj, expr, opt)\n *\n * @type {Object}\n */\nvar redactVariables = {\n  '$$KEEP': function $$KEEP(obj) {\n    return obj;\n  },\n  '$$PRUNE': function $$PRUNE() {\n    return undefined;\n  },\n  '$$DESCEND': function $$DESCEND(obj, expr, opt) {\n    // traverse nested documents iff there is a $cond\n    if (!has(expr, '$cond')) return obj;\n\n    var result = void 0;\n\n    each(obj, function (current, key) {\n      if (isObjectLike(current)) {\n        if (isArray(current)) {\n          result = [];\n          each(current, function (elem) {\n            if (isObject(elem)) {\n              elem = redactObj(elem, expr, opt);\n            }\n            if (!isNil(elem)) result.push(elem);\n          });\n        } else {\n          result = redactObj(current, expr, opt);\n        }\n\n        if (isNil(result)) {\n          delete obj[key]; // pruned result\n        } else {\n          obj[key] = result;\n        }\n      }\n    });\n    return obj;\n  }\n};\n\n// system variables\nvar SYS_VARS = keys(systemVariables);\nvar REDACT_VARS = keys(redactVariables);\n\n/**\n * Returns the key used as the collection's objects ids\n */\nfunction idKey() {\n  return settings.key;\n}\n\n/**\n * Retrieve the value of a given key on an object\n * @param obj\n * @param field\n * @returns {*}\n * @private\n */\nfunction getValue(obj, field) {\n  return obj[field];\n}\n\n/**\n * Resolve the value of the field (dot separated) on the given object\n * @param obj {Object} the object context\n * @param selector {String} dot separated path to field\n * @param deepFlag {Boolean} flag whether to iterate deeply (default: false)\n * @returns {*}\n */\nfunction resolve(obj, selector) {\n  var deepFlag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var names = selector.split('.');\n  var value = obj;\n\n  var _loop = function _loop(i) {\n    var isText = names[i].match(/^\\d+$/) === null;\n\n    if (isText && isArray(value)) {\n      // On the first iteration, we check if we received a stop flag.\n      // If so, we stop to prevent iterating over a nested array value\n      // on consecutive object keys in the selector.\n      if (deepFlag === true && i === 0) {\n        return {\n          v: value\n        };\n      }\n\n      value = value.map(function (item) {\n        return resolve(item, names[i], true);\n      });\n\n      // we mark this value as being multi-valued\n      addMeta(value, { isMulti: true });\n\n      // we unwrap for arrays of unit length\n      // this avoids excess wrapping when resolving deeply nested arrays\n      if (value.length === 1) {\n        value = value[0];\n      }\n    } else {\n      value = getValue(value, names[i]);\n      deepFlag = false; // reset stop flag when we do a direct lookup\n    }\n\n    if (isNil(value)) return 'break';\n  };\n\n  _loop2: for (var i = 0; i < names.length; i++) {\n    var _ret = _loop(i);\n\n    switch (_ret) {\n      case 'break':\n        break _loop2;\n\n      default:\n        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n    }\n  }\n\n  return value;\n}\n\n/**\n * Returns the full object to the resolved value given by the selector.\n * This function excludes empty values as they aren't practically useful.\n *\n * @param obj {Object} the object context\n * @param selector {String} dot separated path to field\n */\nfunction resolveObj(obj, selector) {\n  if (isNil(obj)) return;\n\n  var names = selector.split('.');\n  var key = names[0];\n  // get the next part of the selector\n  var next = names.length === 1 || names.slice(1).join('.');\n  var isIndex = key.match(/^\\d+$/) !== null;\n  var hasNext = names.length > 1;\n  var result = void 0;\n  var value = void 0;\n\n  try {\n    if (isArray(obj)) {\n      if (isIndex) {\n        result = getValue(obj, key);\n        if (hasNext) {\n          result = resolveObj(result, next);\n        }\n        assert(!isUndefined(result));\n        result = [result];\n      } else {\n        result = [];\n        each(obj, function (item) {\n          value = resolveObj(item, selector);\n          if (!isNil(value)) result.push(value);\n        });\n        assert(result.length > 0);\n      }\n    } else {\n      value = getValue(obj, key);\n      if (hasNext) {\n        value = resolveObj(value, next);\n      }\n      assert(!isUndefined(value));\n      result = {};\n      result[key] = value;\n    }\n  } catch (e) {\n    result = undefined;\n  }\n\n  return result;\n}\n\n/**\n * Walk the object graph and execute the given transform function\n * @param  {Object|Array} obj   The object to traverse\n * @param  {String} selector    The selector\n * @param  {Function} fn Function to execute for value at the end the traversal\n * @param  {Boolean} force Force generating missing parts of object graph\n * @return {*}\n */\nfunction traverse(obj, selector, fn) {\n  var force = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  var names = selector.split('.');\n  var key = names[0];\n  var next = names.length === 1 || names.slice(1).join('.');\n\n  if (names.length === 1) {\n    fn(obj, key);\n  } else {\n    // nested objects\n    if (isArray(obj) && !/^\\d+$/.test(key)) {\n      each(obj, function (item) {\n        traverse(item, selector, fn, force);\n      });\n    } else {\n      // force the rest of the graph while traversing\n      if (force === true) {\n        var exists = has(obj, key);\n        if (!exists || isNil(obj[key])) {\n          obj[key] = {};\n        }\n      }\n      traverse(obj[key], next, fn, force);\n    }\n  }\n}\n\n/**\n * Set the value of the given object field\n *\n * @param obj {Object|Array} the object context\n * @param selector {String} path to field\n * @param value {*} the value to set\n */\nfunction setValue(obj, selector, value) {\n  traverse(obj, selector, function (item, key) {\n    item[key] = value;\n  }, true);\n}\n\nfunction removeValue(obj, selector) {\n  traverse(obj, selector, function (item, key) {\n    if (isArray(item) && /^\\d+$/.test(key)) {\n      item.splice(parseInt(key), 1);\n    } else if (isObject(item)) {\n      delete item[key];\n    }\n  });\n}\n\n/**\n * Simplify expression for easy evaluation with query operators map\n * @param expr\n * @returns {*}\n */\nfunction normalize(expr) {\n  // normalized primitives\n  if (inArray(JS_SIMPLE_TYPES, jsType(expr))) {\n    return isRegExp(expr) ? { '$regex': expr } : { '$eq': expr };\n  }\n\n  // normalize object expression\n  if (isObjectLike(expr)) {\n    var exprKeys = keys(expr);\n    var noQuery = intersection(ops(OP_QUERY), exprKeys).length === 0;\n\n    // no valid query operator found, so we do simple comparison\n    if (noQuery) {\n      return { '$eq': expr };\n    }\n\n    // ensure valid regex\n    if (inArray(exprKeys, '$regex')) {\n      var regex = expr['$regex'];\n      var options = expr['$options'] || '';\n      var modifiers = '';\n      if (isString(regex)) {\n        modifiers += regex.ignoreCase || options.indexOf('i') >= 0 ? 'i' : '';\n        modifiers += regex.multiline || options.indexOf('m') >= 0 ? 'm' : '';\n        modifiers += regex.global || options.indexOf('g') >= 0 ? 'g' : '';\n        regex = new RegExp(regex, modifiers);\n      }\n      expr['$regex'] = regex;\n      delete expr['$options'];\n    }\n  }\n\n  return expr;\n}\n\n/**\n * Computes the actual value of the expression using the given object as context\n *\n * @param obj the current object from the collection\n * @param expr the expression for the given field\n * @param field the field name (may also be an aggregate operator)\n * @param opt {Object} extra options\n * @returns {*}\n */\nfunction computeValue(obj, expr) {\n  var field = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var opt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  opt.root = opt.root || obj;\n\n  // if the field of the object is a valid operator\n  if (inArray(ops(OP_AGGREGATE), field)) {\n    return aggregateOperators[field](obj, expr, opt);\n  }\n\n  // we also handle $group accumulator operators\n  if (inArray(ops(OP_GROUP), field)) {\n    // we first fully resolve the expression\n    obj = computeValue(obj, expr, null, opt);\n    assert(isArray(obj), field + ' expression must resolve to an array');\n    // we pass a null expression because all values have been resolved\n    return groupOperators[field](obj, null, opt);\n  }\n\n  // if expr is a variable for an object field\n  // field not used in this case\n  if (isString(expr) && expr.length > 0 && expr[0] === '$') {\n    // we return system variables as literals\n    if (inArray(SYS_VARS, expr)) {\n      return systemVariables[expr](obj, null, opt);\n    } else if (inArray(REDACT_VARS, expr)) {\n      return expr;\n    }\n\n    // handle selectors with explicit prefix\n    var sysVar = SYS_VARS.filter(function (v) {\n      return expr.indexOf(v + '.') === 0;\n    });\n\n    if (sysVar.length === 1) {\n      sysVar = sysVar[0];\n      if (sysVar === '$$ROOT') {\n        obj = opt.root;\n      }\n      expr = expr.substr(sysVar.length); // '.' prefix will be sliced off below\n    }\n\n    return resolve(obj, expr.slice(1));\n  }\n\n  // check and return value if already in a resolved state\n  switch (jsType(expr)) {\n    case T_ARRAY:\n      return expr.map(function (item) {\n        return computeValue(obj, item);\n      });\n    case T_OBJECT:\n      var result = {};\n      each(expr, function (val, key) {\n        result[key] = computeValue(obj, val, key, opt);\n        // must run ONLY one aggregate operator per expression\n        // if so, return result of the computed value\n        if (inArray(ops(OP_AGGREGATE, OP_GROUP), key)) {\n          // there should be only one operator\n          assert(keys(expr).length === 1, \"Invalid aggregation expression '\" + JSON.stringify(expr) + \"'\");\n          result = result[key];\n          return false; // break\n        }\n      });\n      return result;\n    default:\n      return expr;\n  }\n}\n\n/**\n * Returns a slice of the array\n *\n * @param  {Array} xs\n * @param  {Number} skip\n * @param  {Number} limit\n * @return {Array}\n */\nfunction slice(xs, skip) {\n  var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  // MongoDB $slice works a bit differently from Array.slice\n  // Uses single argument for 'limit' and array argument [skip, limit]\n  if (isNil(limit)) {\n    if (skip < 0) {\n      skip = Math.max(0, xs.length + skip);\n      limit = xs.length - skip + 1;\n    } else {\n      limit = skip;\n      skip = 0;\n    }\n  } else {\n    if (skip < 0) {\n      skip = Math.max(0, xs.length + skip);\n    }\n    assert(limit > 0, 'Invalid argument value for $slice operator. Limit must be a positive number');\n    limit += skip;\n  }\n  return Array.prototype.slice.apply(xs, [skip, limit]);\n}\n\n/**\n * Compute the standard deviation of the data set\n * @param  {Object} ctx An object of the context. Includes \"data:Array\" and \"sampled:Boolean\".\n * @return {Number}\n */\nfunction stddev(ctx) {\n  var sum = reduce(ctx.data, function (acc, n) {\n    return acc + n;\n  }, 0);\n  var N = ctx.data.length || 1;\n  var correction = ctx.sampled === true ? 1 : 0;\n  var avg = sum / (N - correction);\n  return Math.sqrt(reduce(ctx.data, function (acc, n) {\n    return acc + Math.pow(n - avg, 2);\n  }, 0) / N);\n}\n\n/**\n * Redact an object\n * @param  {Object} obj The object to redact\n * @param  {*} expr The redact expression\n * @param  {*} opt  Options for value\n * @return {*} Returns the redacted value\n */\nfunction redactObj(obj, expr) {\n  var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  opt.root = opt.root || obj;\n\n  var result = computeValue(obj, expr, null, opt);\n  return inArray(REDACT_VARS, result) ? redactVariables[result](obj, expr, opt) : result;\n}\n\n/**\n * Exported to the users to allow writing custom operators\n */\nfunction _internal() {\n  return {\n    computeValue: computeValue,\n    idKey: idKey,\n    ops: ops,\n    resolve: resolve,\n    assert: assert,\n    clone: clone,\n    each: each,\n    err: err,\n    getType: getType,\n    has: has,\n    isArray: isArray,\n    isBoolean: isBoolean,\n    isDate: isDate,\n    isEmpty: isEmpty,\n    isEqual: isEqual,\n    isFunction: isFunction,\n    isNil: isNil,\n    isNull: isNull,\n    isNumber: isNumber,\n    isObject: isObject,\n    isRegExp: isRegExp,\n    isString: isString,\n    isUndefined: isUndefined,\n    keys: keys,\n    map: map\n  };\n}\n\n/**\n * Mixin for Collection types that provide a method `toJSON() -> Array[Object]`\n */\nvar CollectionMixin = {\n\n  /**\n   * Runs a query and returns a cursor to the result\n   * @param criteria\n   * @param projection\n   * @returns {Cursor}\n   */\n  query: function query(criteria, projection) {\n    return new Query(criteria).find(this.toJSON(), projection);\n  },\n\n\n  /**\n   * Runs the given aggregation operators on this collection\n   * @params pipeline\n   * @returns {Array}\n   */\n  aggregate: function aggregate$$1(pipeline) {\n    return new Aggregator(pipeline).run(this.toJSON());\n  }\n};\n\nvar VERSION = '1.3.3';\n\n// mingo!\nvar index = {\n  _internal: _internal,\n  Aggregator: Aggregator,\n  CollectionMixin: CollectionMixin,\n  Cursor: Cursor,\n  OP_AGGREGATE: OP_AGGREGATE,\n  OP_GROUP: OP_GROUP,\n  OP_PIPELINE: OP_PIPELINE,\n  OP_PROJECTION: OP_PROJECTION,\n  OP_QUERY: OP_QUERY,\n  Query: Query,\n  VERSION: VERSION,\n  addOperators: addOperators,\n  aggregate: aggregate,\n  find: find,\n  remove: remove,\n  setup: setup\n};\n\nreturn index;\n\n})));\n"]}